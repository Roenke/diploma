Потоки объектов могут использовать параллелизм для оптимизации производительности. Для того, чтобы некоторый вызов исполнялся с использованием нескольких потоков, достаточно вызвать метод parallelStream у источника, либо метод \mintinline{java}{parallel} у уже имеющегося объекта \mintinline{java}{Stream}. Пример: 
\inputminted{java}{chapter2/code/ParallelStream.java}
При запуске вычислений в параллельном потоке, исходный поток разбивается на множество мелких задач, которые выполняются при помощи\textit{ Fork/Join Pool} \cite{java:forkjoin}, работающий по принципу \textit{work-stealing} \cite{wiki:worksteal}. При этом гарантии могут нарушаться -- промежуточные операции могут быть уже не всегда ленивыми. Это связано с желанием уменьшить необходимую синхронизацию между потоками, поэтому могут выполняться избыточные действия.

Мы не будем ставить задачу научиться отлаживать параллельные потоки. Как правило, там возникают совершенно другие проблемы и для их решения используются подходы, отличные от использования отладчика. Основная цель параллельных потоков заключается в том, чтобы логика, работающая корректно последовательно, работала быстрее. Поэтому разумно оставить возможность отлаживать такие вызовы как последовательные.

Для того, чтобы избавиться от параллелизма можно после каждого вызова, который делает поток параллельным добавить вызов \mintinline{java}{sequential}, тогда поток будет всюду последовательным. Но в текущей реализации поток не может одновременно содержать однопоточные и многопоточные части, поэтому, чтобы сделать его полностью последовательным будет достаточно добавить вызов \mintinline{java}{sequential} перед завершающим вызовом. Это обусловлено дизайном библиотеки, т.к. завершающая операция запускает все вычисления, то и она "принимает решение" сколько потоков использовать.
