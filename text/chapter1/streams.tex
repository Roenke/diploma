\subsection{Функции высших порядков} % TODO: назвать нормально
В 2014 году вышла восьмая версия языка программирования Java. Одними из нововведений обновления 
стала поддержка анонимных функций и библиотека функций высшего порядка для обработки 
последовательностей элементов -- пакет java.util.stream. Кроме добавления этого пакета 
изменения коснулись и ранее определённых классов -- для некоторых объектов естественно 
представление в виде последовательности элементов: коллекции и поток ввода.

Поддержка анонимных функций сделало доступным следующий синтаксис.
\inputminted{java}{chapter1/code/Lambda.java}

После этого данную функцию можно вызвать:
\inputminted{java}{chapter1/code/UseLambda.java}

С точки зрения пользователя, такое определение анонимной функции является более короткой версией следующего использования анонимного класса.

\inputminted{java}{chapter1/code/SameAnonymous.java}

Вместе с классами из пакета java.util.stream анонимные функции позволяют создавать следующие конструкции:

\inputminted{java}{chapter1/code/StreamUsage.java}

С точки зрения результата такой вызов эквивалентен следующей последовательности операторов: 

\inputminted{java}{chapter1/code/CyclesUsage.java}

Важно, что последовательность вызовов в цепочке нельзя воспринимать как трансформацию коллекций. Правильно трактовать подобные вызовы именно как поток объектов. Это значит, что из источника берется объект и последовательно проходит через все операции, пока это возможно, затем это повторяется и для всех остальных. Очевидно, что возможны ситуации, когда все элементы их источника не понадобятся. Операции для которых это верно называются \textit{короткозамкнутыми}. Как следствие, допускаются бесконечные источники, то тогда цепочка методов должна содержать хотя бы одну короткозамкнутую операцию, иначе такой вызов никогда не завершится.

Таким образом, пакет java.util.stream предоставляет возможность отказаться от обычных управляющих конструкций в пользу операций в функциональном стиле. Обычно это приводит к краткости кода, скрывая от программиста детали реализации операций, оставляя лишь семантику операций.

\subsubsection{Части вызова Stream API}
Типичное использование классов из java.util.stream состоит из нескольких частей: сначала 
нужно инициализировать поток объектов, затем выполнить над объектами набор преобразований, 
после чего нужно аггрегировать объекты в результирующее значение. Таким образом все операции 
можно разделить на два класса:
\begin{itemize}
	\item \textbf{Промежуточная операция.} Операция, которая возвращает Stream. Преобразует объектов. Это значит, что после вызова таких 
	операций могут измениться объекты внутри потока, или их порядок. Примеры:
	\begin{itemize}
		\item \textit{map} -- заменяет каждый объект новым значением, сохраняя порядок.
		\item \textit{filter} -- оставляет только те объекты, которые удовлетворяют 
		\item \textit{distint} -- оставляет только различные элементы (сравнение по $equals$ \cite{java:equals})
		\item и многие другие (см \cite{java:stream})
	\end{itemize}
	При этом все промежуточные операции можно разбить на две части по возможности хранить состояние:
	\begin{itemize}
		\item Без состояния. Большинство операций, выполняющие локальные действия над одним 
		объектом. Для таких операций гарантируется, что 
		\item С состоянием. Допускается, что такие операции должны считать весь входной 
		поток, прежде чем начнут работу следующие по порядку операции. В стандартной 
		реализации таких операций две - sorted и distinct.
	\end{itemize}
	\item \textbf{Завершающая операция.} Эта операция запускает вычисления и преобразует 
	объекты из потока, которые до неё доходят в некоторый результат. В качестве результата 
	может выступать, произвольный объект. Как правило, это коллекции, массивы, определенные 
	значения из потока (максимум/минимум по какому-то признаку) и другие.
\end{itemize}

Кроме того, можно выделить объект - источник. Он содержит либо способен генерировать поток объектов. В качестве источника могут выступать коллекции, массивы, функция-генератор, каналы вводы.
\inputminted{java}{chapter1/code/IntStream.java}
Массив, переданный параметром методу Arrays.stream является источником
\inputminted{java}{chapter1/code/ZerosStream.java}
Данный вызов создает бесконечный поток нулей. Анонимная функция-генератор является источником.

\subsubsection{Детали реализации Stream API}
В своей реализации потоки объектов в java используют абстракцию Spliterator 
\cite{java:spliterator}, так же введенную в восьмой версии. Spliterator - это интерфейс, 
который усложняет понятие обычного итератора в java -- объекта, который позволяет обойти 
некоторый набор объектов \cite{java:iterator}. Spliterator хранит свойства объектов которые 
обходятся: их количество, упорядоченность, изменяемость, признак того, что данные уже 
отсортированы и другие. Эти свойства могут быть использованы при выполнении операций над 
потоком объектов. Так же в Spliterator добавлен новый метод split, который позволяет 
разделить множество объектов на две непересекающиеся части, и обойти параллельно. На этой идее основывается реализация параллельных потоков параллельных потоков.

Несмотря на то, что java является объектно-ориентированным языком, не все значения в java 
являются объектами. Исключения составляют примитивные типы, для которых хранение в виде 
объектов невыгодно с точки зрения производительности. По этим же причинам, реализация 
java.util.stream содержит отдельную реализацию для объектов примитивных типов -- IntStream, 
LongStream, DoubleStream -- для поддержки потоков целых и вещественных чисел. 

\subsubsection{Расширения стандартной библиотеки}
Стандартная библиотека предоставляет довольно большой набор промежуточных и завершающих операций. Тем не менее существуют расширения базового интерфейса. Примерами таких расширений служат библиотеки - jOOL \cite{java:jool} и StreamEx \cite{java:streamex}.

Они полностью совместимы со стандартной реализацией и дают те же гарантии. Операции, добавленные в этих библиотеках, как правило упрощают написание кода с использованием интерфейса потоков объектов. Хотя многие из новых операций можно выразить через уже имеющиеся.

\subsubsection{Аналоги в других языках}
Идея обрабатывать множества объектов как потоки в императивных языках не новая. В 2007 году Microsoft представил LINQ (язык интегрированных запросов) для языка $C\#$ \cite{ms:linq}. Он предоставляет очень схожие возможности, но дизайн этого расширения отличен от java.util.stream. В реализации были использованы методы-расширения \cite{ms:ext}, а так же ключевое слово yield \cite{ms:yield}. Так же операции названы по аналогии с SQL, тогда как в java операции имеют аналоги в функциональных языках, например Haskell.

Подобные возможности реализуют коллекции в языке Scala \cite{ho:scala} и абстракция Sequence в языке Kotlin \cite{ho:kotlin}.