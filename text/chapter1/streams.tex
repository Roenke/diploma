\subsection{Функции высших порядков} % TODO: назвать нормально
В 2014 году вышла восьмая версия языка программирования Java. Одними из нововведений обновления 
стала поддержка анонимных функций и библиотека функций высшего порядка для обработки 
последовательностей элементов -- пакет java.util.stream. Кроме добавления этого пакета 
изменения коснулись и ранее определённых классов -- для некоторых объектов естественно 
представление в виде последовательности элементов: коллекции и поток ввода.

Поддержка анонимных функций сделало доступным следующий синтаксис.
\inputminted{java}{chapter1/code/Lambda.java}

После этого данную функцию можно вызвать:
\inputminted{java}{chapter1/code/UseLambda.java}

С точки зрения пользователя, такое определение анонимной функции является более короткой версией следующего использования анонимного класса.

\inputminted{java}{chapter1/code/SameAnonymous.java}

Вместе с классами из пакета java.util.stream анонимные функции позволяют создавать следующие конструкции:

\inputminted{java}{chapter1/code/StreamUsage.java}

С точки зрения результата, такой вызов эквивалентен следующей последовательности операторов: 

\inputminted{java}{chapter1/code/CyclesUsage.java}

TODO: описать преимущества

Важно, что последовательность вызовов в цепочке нельзя воспринимать как трансформацию коллекций. Правильно трактовать подобные вызовы именно как поток объектов. Это значит, что из источника берется объект и последовательно проходит через все операции, пока это возможно, затем это повторяется и для всех остальных объектов. Очевидно, возможны ситуации, когда все элементы их источника не понадобятся. Операции, для которых это верно называются \textit{короткозамкнутыми}. Как следствие, допускаются бесконечные источники, но тогда цепочка методов должна содержать хотя бы одну короткозамкнутую операцию, иначе такой вызов никогда не завершится.

Таким образом, пакет java.util.stream предоставляет возможность отказаться от обычных управляющих конструкций в пользу операций в функциональном стиле. Обычно это приводит к краткости кода, скрывая от программиста детали реализации операций, оставляя лишь семантику операций.

\subsubsection{Части вызова Stream API}
Типичное использование классов из java.util.stream состоит из нескольких частей: сначала 
нужно инициализировать поток объектов, затем выполнить над объектами набор преобразований, 
после чего нужно агрегировать объекты в результирующее значение. Все операции 
можно разделить на два класса:
\begin{itemize}
	\item \textbf{Промежуточная операция.} Операция, которая возвращает Stream. Может инициировать поток объектов из источника, преобразовать уже существующий (далее будем называть такой поток входным). После вызова таких операций создается новый объект Stream. Примеры:
	\begin{itemize}
		\item \mintinline{java}{map} -- заменяет каждый объект новым значением, сохраняя порядок;
		\item \mintinline{java}{filter} -- оставляет только те объекты, которые удовлетворяют;
		\item \mintinline{java}{distinct} -- оставляет только различные элементы (сравнение по $equals$ \cite{java:equals});
		\item и многие другие (см \cite{java:stream}).
	\end{itemize}
	При этом все промежуточные операции можно разбить на две части согласно возможности хранить состояние:
	\begin{itemize}
		\item Без состояния. Большинство операций, выполняющие локальные действия над одним 
		объектом. Для таких операций гарантируется, что объекты обрабатываются независимо. Иными словами, чтобы произвести новый элемент потока таким операциям не нужно вычитывать более одного элемента из входного потока;
		\item С состоянием. Такие операции обрабатывают поток не независимо. Они могут считать часть входного потока (возможно, прочитать его целиком), прежде чем вернуть значения после себя. В стандартной реализации таких операций две - sorted и distinct.
	\end{itemize}
	\item \textbf{Завершающая операция.} Вызывается на заранее созданном объекте Stream. Запускает вычисления, преобразуя объекты из потока в некоторый результат -- произвольный объект. Как правило, это коллекции, массивы, определенные значения из потока (максимум/минимум по какому-либо признаку) и другие. Примеры:
	\begin{itemize}
		\item \mintinline{java}{toArray} -- сохраняет все объекты из потока в массив;
		\item \mintinline{java}{max} -- находит среди объектов в потоке максимум по заданному критерию сравнения;
		\item и многие другие (см \cite{java:stream}).
	\end{itemize}
\end{itemize}

Кроме того, можно выделить объект - источник. Он может быть рассмотрен как последовательность объектов. В качестве источника могут выступать коллекции, массивы, функция-генератор, поток ввода.
\inputminted{java}{chapter1/code/IntStream.java}
Массив, переданный параметром методу Arrays.stream является источником.
\inputminted{java}{chapter1/code/ZerosStream.java}
Данный вызов создает бесконечный поток нулей. Анонимная функция-генератор является источником.
Любой объект может быть рассмотрен как поток объектов (из одного объекта):

\mintinline{java}{Stream.of(object)}

\subsubsection{Детали реализации Stream API}
В своей реализации потоки объектов в java используют абстракцию Spliterator 
\cite{java:spliterator}, так же введенную в восьмой версии. Spliterator - это интерфейс, 
который усложняет понятие обычного итератора в java -- объекта, позволяющий обойти 
некоторый набор объектов \cite{java:iterator}. Spliterator хранит свойства объектов, которые 
обходятся: их количество, упорядоченность, изменяемость, признак того, что данные уже 
отсортированы и другие. Эти свойства могут быть использованы при выполнении операций над 
потоком объектов. Так же в Spliterator добавлен новый метод split, который позволяет 
разделить множество объектов на две непересекающиеся части, и обойти параллельно. На этой идее основывается реализация параллельных потоков параллельных потоков.

Несмотря на то, что java является объектно-ориентированным языком, не все значения в java 
являются объектами. Исключения составляют примитивные типы, для которых хранение в виде 
объектов невыгодно с точки зрения производительности. По этим же причинам, реализация 
java.util.stream содержит отдельную специализацию для объектов примитивных типов -- IntStream, 
LongStream, DoubleStream -- для потоков целых и вещественных чисел. 

\subsubsection{Расширения стандартной библиотеки}
Стандартная библиотека предоставляет довольно большой набор промежуточных и завершающих операций. Тем не менее существуют расширения базового интерфейса. Примерами таких расширений служат библиотеки - jOOL \cite{java:jool} и StreamEx \cite{java:streamex}.

Они полностью совместимы со стандартной реализацией и дают те же гарантии. Операции, добавленные в этих библиотеках, как правило упрощают написание кода с использованием интерфейса потоков объектов. Хотя многие из новых операций можно выразить через уже имеющиеся.

\subsubsection{Аналоги в других языках}
Идея обрабатывать множества объектов  потоки в императивных языках не нова, -- в 2007 году Microsoft представил LINQ (язык интегрированных запросов) для языка $C\#$ \cite{ms:linq}. Он предоставляет очень схожие возможности с java.util.stream, но дизайн решений различается. В реализации LINQ используются возможности языка C\#, отсутствующие в Java: методы-расширения \cite{ms:ext}, а так же ключевое слово yield \cite{ms:yield}. Кроме того, в расширении от Microsoft, операции названы по аналогии с SQL, в java же, операции имеют аналоги в функциональных языках, например Haskell.

Подобные возможности реализуют коллекции в языке Scala \cite{ho:scala} и абстракция Sequence в языке Kotlin \cite{ho:kotlin}.