\section{Подход к решению задачи}
Прежде чем приступить к описанию решения, необходимо понять, какие гарантии предоставляет Stream API, а так же какие предположения можно делать о пользовательском коде.

\subsection{Гарантии Stream API}
Промежуточные операции всегда ленивые. Это значит, что операция не будет запрашивать следующий элемент, если может корректно вычислиться без его использования.
\begin{itemize}
	\item Это исключает ситуации, когда из каких-то промежуточных операций вынимались объекты, но затем не использовались.
	\item Но это не исключает, что некоторым промежуточным операциям потребуется прочитать более одного объекта, чтобы что-либо вычислить. (sorted, distinct)
	\item Следствие: нет вызова терминальной операции - нет вычислений.
\end{itemize}

\subsection{Требования к коду пользователя}

Кроме предоставления гарантий, Stream API делает предположения о коде пользователя. Соблюдение следующих требований снизит вероятность неожиданного поведения вызовов Stream API. Эти требования особенно критичны в случае использования параллельных потоков.

\begin{itemize}
	\item Операции над объектами не могут модифицировать объект-источник.
	\inputminted{java}{chapter2/code/SourceModification.java}
	\item Функции над объектами в потоке не должны иметь состояния (когда это возможно).
	\inputminted{java}{chapter2/code/StatefulOperation.java}
	\item Однажды созданный объект Stream может вызвать лишь одну терминальную операцию. Если это требование нарушено, то произойдет исключение.
	\inputminted{java}{chapter2/code/OneTermination.java}
\end{itemize}

\subsection{Параллельные потоки объектов}
\input{character2/parallel.tex}

\subsection{Поиск подходящего вызова}

\subsection{Построение выражения для вычисления}

\subsection{Вычисление выражения}

\subsection{Интерпретация результата}

\subsection{Визуализация}
