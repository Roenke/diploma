\section{Подход к решению задачи}
Прежде чем приступить к описанию решения, необходимо понять, какие гарантии предоставляет Stream API, а так же какие предположения можно делать о пользовательском коде.

\subsection{Гарантии Stream API}
Промежуточные операции всегда ленивые. Это значит, что операция не будет запрашивать следующий элемент, если может корректно вычислиться без его использования.
\begin{itemize}
	\item Это исключает ситуации, когда из каких-то промежуточных операций вынимались объекты, но затем не использовались.
	\item Но это не исключает, что некоторым промежуточным операциям потребуется прочитать более одного объекта, чтобы что-либо вычислить. (sorted, distinct)
	\item Следствие: нет вызова терминальной операции - нет вычислений.
\end{itemize}

\subsection{Требования к коду пользователя}
Кроме предоставляемых гарантий Stream API делает предположения о коде пользователя. И есть он удовлетворяет этим требованиям, то это снизит вероятность неожиданного поведения вызовов Stream API.

\subsection{Параллелизм}
Потоки объектов могут использовать параллелизм для оптимизации производительности. Они используют Fork-Join Pool, работающий по принципу work-stealing \cite{wiki:worksteal}. При этом гарантии могут нарушаться -- в параллельном потоке промежуточные операции могут быть не всегда ленивыми. Это связано с желанием уменьшить необходимую синхронизацию между потоками, поэтому могут выполняться избыточные операции.

Поэтому мы не будем ставить задачу научиться отлаживать параллельные потоки. Как правило, там возникают совершенно другие проблемы и для их решения используются подходы, отличные от использования отладчика. Основная идея параллельных потоков, чтобы логика которая правильно работает последовательно работала быстрее. При этом, можно оставить возможность отлаживать параллельные потоки как последовательные.

\subsection{Поиск подходящего вызова}

\subsection{Построение выражения для вычисления}

\subsection{Вычисление выражения}

\subsection{Интерпретация результата}

\subsection{Визуализация}
