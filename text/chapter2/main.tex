\section{Подход к решению задачи}\label{chapter2}
Прежде чем приступить к описанию решения, необходимо понять, какие гарантии предоставляет Stream API, а так же какие предположения можно делать о пользовательском коде.

\subsection{Гарантии Stream API}\label{java:guarantees}
Промежуточные операции всегда ленивые. Это значит, что операция не будет запрашивать следующий элемент, если может корректно вычислиться без его использования.
\begin{itemize}
	\item Это исключает ситуации, когда из каких-то промежуточных операций вынимались объекты, но затем не использовались.
	\item Но это не исключает, что некоторым промежуточным операциям потребуется прочитать более одного объекта, чтобы что-либо вычислить. (sorted, distinct)
	\item Следствие: нет вызова терминальной операции - нет вычислений.
\end{itemize}

\subsection{Требования к коду пользователя} \label{code:demands}

Кроме предоставления гарантий, Stream API делает предположения о коде пользователя. Соблюдение следующих требований снизит вероятность неожиданного поведения вызовов Stream API. Эти требования особенно критичны в случае использования параллельных потоков.

\begin{itemize}
	\item Операции над объектами не могут модифицировать объект-источник.
	\inputminted{java}{chapter2/code/SourceModification.java}
	\item Функции над объектами в потоке не должны иметь состояния (когда это возможно).
	\inputminted{java}{chapter2/code/StatefulOperation.java}
	\item Однажды созданный объект Stream может вызвать лишь одну терминальную операцию. Если это требование нарушено, то произойдет исключение.
	\inputminted{java}{chapter2/code/OneTermination.java}
\end{itemize}

\subsection{Параллельные потоки объектов}
\input{character2/parallel.tex}

\subsection{Определение подходящего вызова}
При отладке программ внутри среды разработки пользователь видит текущее положение программы относительно исходного кода и текущее состояние программы (локальные переменные, объекты и их поля, потоки, стек и другие). Виртуальная машина Java исполняет инструкции байт-кода, заменяя их набором машинных команд. Машинные TODO. Можно считать, что существует какой способ отображения инструкций байт-кода на исходный код, реализуемый средой разработки и благодаря которому, мы можем говорить о текущем положении программы не в термах машинных комманд или java байт-кода, а в терминах исходного java кода. Поэтому, под позицией отладчика будем понимать строку в исходном коде.

Прежде чем начать отладку цепочки Stream API, необходимо определить её границы и понять, достаточно ли данных для её вычисления.

В отладчике для каждого из потоков всегда определено текущее положение указателя инструкций.  Определим множество положений указателя инструкций относительно вызова цепочки Stream API когда можно начинать отладку этой цепочки. При вызове цепочки в ней могут участвовать объявленные ранее переменные и значения полей. Таким образом, отлаживать вызов, который находится значительно позже, чем текущая инструкция, не имеет смысла (возможно, имеющихся данных будет недостаточно). Текущая строка отладчика отмечена стрелкой \mintinline{java}{=>}.

\inputminted{java}{chapter2/code/FarToCall.java}

Если же все инструкции до вызова выполнены, значит все переменные и поля были инициализированы и можно начать его отладку. 

\inputminted{java}{chapter2/code/BeforeCall.java}

Начинать отладку можно и после начала исполнения цепочки, т.к. мы предположили, что вызов не имеет побочных эффектов, которые изменят окружение.
\inputminted{java}{chapter2/code/InEvaluation.java}

После того, как вызов завершен, он больше не подходит для отладки. Во-первых, может быть уже другой вызов, который подходит. Во-вторых окружение может измениться, изменив начальную семантику вызова.
\inputminted{java}{chapter2/code/AfterCall.java}

В случае показанной на примере для отладки подходит уже следующая цепочка: \mintinline{java}{transformed.stream().forEach(x -> collection.add(x))}

Таким образом, отладка допустима, если текущее положение отладчика между непосредственным началом вызова потока и до его завершения.

\subsubsection{Цепочки в других элементах стека вызовов}
При отладке пользователь может сменить элемент стека вызовов. В другом элементе стека позиция отладчика находится на вызове метода. Этот вызов может находиться внутри цепочки Stream API. А значит, такая цепочка подходит для отладки.
\inputminted{java}{chapter2/code/NestedMethod.java}

При переключении элемента стека в функцию \textbf{nestedExample} вызов Stream API внутри неё должен быть доступен для отладки.

\subsubsection{Неоднозначные вызовы}
Из одного и того же положения отладчика может быть доступно сразу несколько подходящих вызовов Stream API:
\begin{itemize}
	\item Внутри одного арифметического выражения;
	\inputminted{java}{chapter2/code/AmbiguousPlus.java}
	\item Аргументы некоторого вызова;
	\inputminted{java}{chapter2/code/AmbiguousArgs.java}
	\item Параметр другого вызова Stream API;
	\inputminted{java}{chapter2/code/AmbiguousNested.java}
	\item Вызов находится в объемлющем коде;
	\inputminted{java}{chapter2/code/AmbiguousLambda.java}
	\item В одной цепочке методов есть несколько последовательных цепочек с терминальной операцией;
	\inputminted{java}{chapter2/code/AmbiguousLinkedChains.java}
\end{itemize}
Все такие цепочки подходят для отладки.

\subsubsection{Незавершенные цепочки}\label{java:incomplete}
Согласно \ref{java:guarantees} цепочки методов Stream API без терминальной операции не запускают вычисление, значит и отлаживать их не нужно.

\subsubsection{Присваивание объекта потока в переменную}
Поскольку Stream API это просто набор классов, а не специальный синтаксис, то цепочки создают обычные объекты, с которыми можно обращаться как с любыми другими объектами. В этом контексте интерес представляет операция присваивания в переменную.
\inputminted{java}{chapter2/code/AssignToVariable.java}

Это вносит некоторые проблемы. Ранее мы рассматривали цепочки методов Stream API как нечто неделимое, но теперь видим, что это не так. Причем выражение, инициализирующая переменную \mintinline{java}{even}, не содержит завершающей операции, а значит, это выражение нельзя отлаживать (см \ref{java:incomplete}).

С другой стороны, выражение \mintinline{java}{even.count()} нельзя запустить повторно.

Этот случай достаточно прост, и можно решить, что можно посмотреть, как инициализируется переменная \mintinline{java}{even}, затем объединить инициализацию с терминальной операцией, получив цепочку с завершающей операцией, не упустив промежуточные:

\mintinline{java}{final long size = collection.stream().filter(x -> x % 2 == 0).count()}
	
Но в общем случае это решение не сработает. Этот пример слишком прост, и на практике могут встретиться и более сложные случаи:
\inputminted{java}{chapter2/code/AssignToVariableHardCase.java}

В этом случае тем же способом уже не справиться (хотя этот случай выглядит более близким к практике). Поэтому для таких вызовов будем находить лишь ту часть, которая относится только к последней части цепочки (с терминальной операцией). Заметим, что это инвалидирует поток в переменной even, поэтому лучше предупреждать об этом пользователя.

\subsection{Построение состояний и переходов}
В \ref{code:demands} описаны требования к коду пользователя, который использует Stream API. Эти требования позволяют сделать предположение, что вызов не имеет побочных эффектов и его можно повторить несколько раз, получив тот же самый результат.

Основная идея состоит в том, чтобы запустить вычисление модифицированного вызова Stream API, результат которого совпадет с исходным, при этом новая цепочка собирает информацию, полезную для процесса отладки.

\subsubsection{Выражение для сбора отладочной информации}\label{build-expression}
Для того, чтобы собрать информацию о том, какие объекты проходили через поток можно использовать метод \mintinline{java}{peek}. Добавив такой вызов между каждой промежуточной операцией мы сможем найти какие объекты были внутри потока.

Рассмотрим пример:

Данный вызов возвращает список имен людей, чей возраст меньше 18 лет, упорядоченный по возрастанию.
\inputminted{java}{chapter2/code/StreaMWithoutPeeks.java}
При помощи метода \mintinline{java}{peek} можно наблюдать промежуточные состояния в потоке:
\inputminted{java}{chapter2/code/StreamWithPeeks.java}

Даже если мы будем просто печатать элементы в методе peek (с указанием где именно, то мы получим нечто полезное). Для некоторого списка людей вызов может напечатать следующее. В квадратных скобках указан возраст. 
\inputminted{java}{chapter2/code/peekResults.txt}

Заметим, что из такого вывода можно извлечь следующую информацию:
\begin{itemize}
	\item \textbf{Последовательность} прохождения объектов через цепочку вызовов. Напечатанные строки идут в порядке исполнения программы. Значит, сначала из источника был взят объект с \mintinline{java}{id = 1}, затем он прошел фильтрацию и попал в sorted, и так далее.
	\item \textbf{Результат фильтрации}. Можно увидеть все значения, которые прошли фильтрацию -- это ровно те значения, которые мы наблюдали после вызова \mintinline{java}{filter}.
	\item \textbf{Свойства вызовов.} Вызов sorted имеет состояние и требует выполнить весь поток до своего вызова. Поэтому пока объекты в источнике не закончились после вызова sorted ничего не происходило.
	\item \textbf{Множества } объектов до и после вызова. Обратим внимание, что мы печатаем положение метода peek, поэтому можно понять множества объектов, которые были до и после каждого из вызовов.
	\item \textbf{Преобразования} объектов. На примере вызова map, видно, что в последовательных событиях содержится преобразование -- извлечение имени человека: \mintinline{java}{{id = 1, name = Vasily, age = 10} => Vasily}
\end{itemize}

Приведенный лог плох тем, что он описывает поведение всего потока целиком, а не каждого вызова в отдельности. Этот недостаток легко исправить: для каждой операции в цепочке можем рассмотреть только те записи, которые были сделаны непосредственно до и сразу после него. Таким образом, получим два набора объектов. Объекты в этих наборах можно упорядочить по времени появления в логе. Будем называть эти упорядоченные множества \textbf{состояниями} потока до и после промежуточной операции. 

Чтобы построить их достаточно добавить в поток метод peek между всеми операциями в потоке. Задача добавленных peek'ов -- сохранить объект который в него пришел. Кроме того, добавим глобальное время, которое будет увеличиваться, когда следующий элемент был запрошен у одного из исходных промежуточных объектов Stream. Время, в которое наблядается объект в методе peek -- уникальный идентификатор для этого объекта в рамках данного запуска цепочки. 

\inputminted{java}{chapter2/code/LocalChainModification.java}

Таким образом, для вызова \mintinline{java}{call} мы сможем составить состояние потока до него и после него:
\begin{equation*}
	L = \{t_i, obj_i\}, R = \{t_j, obj_j\}
\end{equation*}

Объекты полученные до вызова \mintinline{java}{call} обозначим $L$, а после \mintinline{java}{call} -- $R$

После этого нужно восстановить переходы между множествами $L$ и $R$, которые соответствуют вызову \mintinline{java}{call}. Для удобства описания следующих алгоритмов введем проекции для элементов множеств $L$ и $R$. Пусть $x = (t, obj)$ элемент одного из этих множеств, тогда проекции задаются правилами:

\begin{align*}
	time(x) &= t \\
	object(x) &= obj
\end{align*}

Множеством \textbf{переходов} будем называть множество $T \subset L \times R$. Элемент этого множества $(l, r), $ где $l \in L, r \in R$ несет следующую информацию: элемент потока $r$ является результатом воздействия операции \mintinline{java}{call} на элемент $l$.

Для большинства промежуточных операций множеств $L$ и $R$ достаточно для построения переходов. Единственное исключение -- промежуточная операция \mintinline{java}{distinct}. Решение для него предложим немного позже в \ref{distinct}.

Таким образом нам удалось локализовать задачу поиска переходов для объектов внутри потока. Вместо того, чтобы пытаться отследить путь объекта через весь поток, мы получили задачу восстановления переходов для промежуточных вызовов по-отдельности. Эта задача имеет решение абсолютно для всех промежуточных вызовов, которые есть в стандартной реализации. Разрешив переходы для всех промежуточных операций, можно последовательно восстановить историю объекта уже внутри целого потока. Это даст удобный способ понять как объект попал в любую часть потока, а значит, появилась возможность быстрее понять, что именно работает не так как ожидается.
\subsubsection{Вычисление выражения}
Выше мы получили формальную постановку задачи. Для решения этой задачи на практике нам нужно иметь возможность построить множества $L$ и $R$. Для этого нам достаточно уметь вычислять модифицированную цепочку (после добавления методов peek, и возможно каких-либо других методов, которые не влияют на итоговый результат).

При попадании на точку останова, отладчики сред разработки предоставляют возможность вычислять выражения на java.

Существует 2 способа вычислить выражение. 
\begin{itemize}
	\item JDI. Java Debug Interface позволяет взаимодействовать с объектами на удаленной виртуальной машине при помощи объектов-посредников. Эти объекты позволяют узнать тип объекта, получить значение полей, вызывать методы, создать новый экземпляр, передать в качестве параметра в другой метод и другие. Зачастую для вычисления выражений хватает интерфейса JDI. Но не всегда -- отсутствуют возможности определять новые классы, а значит не позволяют в выражениях нельзя использовать синтаксис, приводящий к определению новых классов. Это ограничение запрещает использование анонимных классов и анонимных функций.
	\item Загрузка новых классов. Основным достоинством этого подхода является возможность определить новые классы, а значит -- в выражениях можно использовать анонимные классы и функции. Недостатком является то, что прежде чем загрузить класс, его нужно скомпилировать, а это влечет запуск компилятора и процесс компиляции. С другой стороны, после того как код загружен, он сможет исполняться быстрее, чем с использованием JDI (нет накладных расходов на взаимодействие через объекты-посредники \ref{jdpa}).
\end{itemize}

В нашем случае, большинство промежуточных операций принимают параметр, который может быть анонимным классом, либо анонимной функцией. Это не позволяет использовать первый способ, поэтому у нас нет выбора и будем использовать второй.

\subsubsection{Интерпретация результата}\label{interpret}

Как мы сказали в \ref{build-expression}, результатом выполнения выражения является набор множеств $L$ и $R$ для каждой промежуточной операции. Элементы этих множеств это пары $\{t_i, x_i\}$, $t_i$ -- это целое число, $x_i$ -- это соответствующий объект-посредник для объекта, который был на виртуальной машине, код на которой мы хотим отладить (см TODO). Будем считать, что элементы внутри множест $L$ и $R$ упорядочены по времени. Иными словами, $t_i < t_{i + 1}$. Рассмотрим правила построения переходов для каждого из промежуточных вызовов стандартной реализации Stream API.
\begin{itemize}
	\item \mintinline{java}{map} -- Это промежуточная операция без состояний -- она сразу же вернёт новый элемент потока. Таким образом для элемента $\{t_i, x_i\} = l \in L$, будет соответствовать в точности один элемент $\{t_j, y_j\} = r \in R$, такой, что $t_j = t_i + 1$. Таким образом, мы нашли переход $l <=> r$.
	\item \mintinline{java}{filter} -- У применения операции \mintinline{java}{filter} на элемент есть два исхода: он останется в потоке, либо будет отброшен. Если он останется, то сразу же вернется в поток. Это значит, что если объект $\{t_i, x_i\} = l \in L$ прошёл фильтрацию, следовательно найдется элемент $\{t_j, y_j\} = r \in R$, такой что $t_j = t_i + 1$. Если же условие не выполнилось, то в следующий момент исключена ситуация, когда описанный элемент $r$ будет в множестве $R$, т.к. операция \mintinline{java}{filter} не имеет состояния и не может выдать новый элемент, прежде чем прочитает следующий, а значит значение $t_j > t_i + 1$. 
	\item \mintinline{java}{flatMap} -- В результате применения flatMap один объект в потоке заменяется на 0 или больше новых объектов. Аналогично \mintinline{java}{filter}, воспользуемся тем, что \mintinline{java}{flatMap} не может считывать следующие значения, до тех пор, пока можно возвращать значения, соответствующие считанному в прошлый раз. Рассмотрим элемент $\{t_i, x_i\} = l \in L$, для которого мы хотим построить переходы. Далее возможны два случая.
	\begin{itemize}
		\item Существует элемент $\{t_{i + 1}, x_{i + 1}\} \in L$. Это значит, что элементы из $R$, которые соответствуют $l$ не могли появится раньше момента $t_i$, и не позже $t_{i + 1}$. Таким образом, получили переходы $l <=> r, \\ r \in \{\{t_j, x_j\} \in R : t_i < t_j < t_{i + 1}\}$.
		\item $l$ - последний в $L$. Аналогичные рассуждения, но $t_{i + 1} = +\infty$
	\end{itemize}
	\item \mintinline{java}{sorted} -- В результате применения операции sorted объекты в потоке не изменяются, но изменяется их порядок. Множество переходов в этом случае $T = \{(l, r)\} = \{(\{t_i, obj\}, \{t_j, obj\})\}$. То есть пары, в которых совпадают объекты, но различные значения моменты времени, когда объект наблюдался в потоке. В случае, если в потоке были идентичные объекты (для которых верно, что \mintinline{java}{obj1 == obj2}), нужно добавить ограничение, что каждый элемент из множества $L$ входит ровно в один переход в $T$. Аналогичное ограничение верно и для элементов множества $R$.
\end{itemize}

Выше перечислены методы, для которых построение переходов различается. Для остальных вызовов можно использовать эти же алгоритмы, т.к. они в смысле переходов являются частным случаев описанных выше операций.
\begin{itemize}
	%linked
	\item \mintinline{java}{limit(k)} -- частный случай \mintinline{java}{filter} -- фильтрацию прошли только первые $k$ элементов;
	\item \mintinline{java}{skip(k)} -- частный случай \mintinline{java}{filter} -- первые $k$ элементов не прошли фильтрацию, а все остальные прошли;
	\item \mintinline{java}{peek} -- частный случай \mintinline{java}{filter} -- все элементы прошли фильтрацию;
	\item \mintinline{java}{onClose} -- частный случай peek;
	\item \mintinline{java}{flatMapToInt/flatMapToLong/flatMapToDouble} -- Частный случай \mintinline{java}{flatMap};
	\item \mintinline{java}{mapToInt/mapToLong/mapToDouble/mapToObj} -- Частный случай \mintinline{java}{map};
	\item \mintinline{java}{boxed} -- Частный случай \mintinline{java}{mapToObj}.
\end{itemize}  


\subsubsection{Решение для операции distinct}\label{distinct}
\mintinline{java}{distinct} -- промежуточная операция c состоянием, поэтому прежде чем что-либо вернуть, ей может понадобиться прочитать весь входной поток. Результатом является поток объектов, для которого гарантируется, что все объекты попарно различны (в отношении \mintinline{java}{equals}\cite{java:equals}). Новых объектов при этом появиться не может.

Таким образом, в результате этого вызова из потока может исчезнуть часть объектов. На первый взгляд, эта операция является частным случаем операции \mintinline{java}{filter}: в ней так же часть элементов из потока будут отброшены. Но, в отличие от \mintinline{java}{filter} объекты обрабатываются не независимо друг от друга, поэтому рассуждения, представленные в \ref{interpret} помогут лишь увидеть какие элементы прошли дальше, но узнать причин, но которым другие были отброшены не получится. Для установления этих причин необходимо узнать, какие объекты равны друг другу. Но имея лишь состояния поток до и после операции \mintinline{java}{distinct}, восстановить эту информацию невозможно. Проблема возникает, когда объект был отфильтрован в результате вызова. Всё что мы можем о нем сказать, что он равен ровно одному объекту из тех, которые были после вызова. Но какому именно, сказать нельзя. (Решение попарно сравнить все объекты нам не подходит, т.к. оно квадратичное)

Для решения описанной проблемы используем следующий подход. В java операция equals должна удовлетворять отношению эквивалентности. Тогда множество объектов $L$ можно разбить на классы эквивалентности по \mintinline{java}{equals} для объектов $object(l), l \in L$ на непересекающиеся множества $L_1, L_2, .., L_k$. 

Заметим, что объекты в множестве $R$ -- это, согласно семантике \mintinline{java}{distinct}, представители каждого из классов эквивалентности. Таким образом, для того, чтобы построить переходы, нужно взять объект $r \in R$, найти класс эквивалентности $L_i$, к которому он принадлежит, и построить переходы $(l, r) \forall l \in L_i$

\subsubsection{Переходы для завершающих операций}
Иногда может быть интересно узнать, почему в результате выполнения цепочки вызовов получился тот или иной результат. Поэтому для операций, это можно понять при помощи переходов так же поставим задачу их построить.

Среди всех завершающих операций выделим несколько и для каждой из них опишем способ получения переходов:

\begin{itemize}
	\item \mintinline{java}{toArray} -- наиболее простая завершающая операция. Объекты, которые были в потоке до неё переходят, в элементы массива, сохраняя порядок.
	\item \mintinline{java}{min/max/findFirst/findAny} -- вызовы, которые возвращают Optional \cite{java:optional}. Возможно сделать переход для объектов, которые равны содержимому Optional.
	\item \mintinline{java}{allMatch} -- короткозамкнутая завершающая операция. Возвращает \mintinline{java}{true}, если все объекты в потоке удовлетворяют переданному предикату, иначе \mintinline{java}{false}. Если значение false, то для отладки будет полезно знать, для каких объектов предикат не верен.
	
	Чтобы получить объекты, для которые предикат не верен, достаточно произвести описанную ниже трансформацию цепочки. Пусть исходная цепочка имеет вид:
	
	\mintinline{java}{source.stream()./* ops */.allMatch(predicate);}

	Новая цепочка:
	
	\inputminted{java}{chapter2/code/allMatchTransform.java}
	
	Все объекты, попавшие в метод peek, не прошли проверку \mintinline{java}{predicate}, а значит, нарушают условие \mintinline{java}{allMatch}. Результат вызова новой цепочки совпадает в результатом исходной, потому что, если поток пуст, то вызов \\ \mintinline{java}{allMatch(x -> false)} вернёт \mintinline{java}{true}. Заметим, что предикат вызовется по одному разу для каждого объекта, как и в исходной цепочке.
	
	\item \mintinline{java}{anyMatch} -- Короткозамкнутая завершающая операция. Возвращает \mintinline{java}{true}, если хотя бы один объект удовлетворяет переданному предикату, иначе \mintinline{java}{false}. Если значение оказалось true, то для целей отладки может быть полезно знать для каких объектов выполнился предикат.
	
	Чтобы найти эти объекты, снова трансформируем цепочку, но уже немного иначе. Пусть исходная цепочка имеет следующий вид: 
	
	\inputminted{java}{chapter2/code/anyMatch.java}
	
	После трансформации она будет иметь следующий вид:
	
	\inputminted{java}{chapter2/code/anyMatchTransform.java}
	
	По аналогии с \mintinline{java}{allMatch} можно понять, что такая цепочка имеет тот же результат, позволяет найти интересующие объекты и вызывает \mintinline{java}{predicate} ровно для тех же самых объектов, причем делает это не чаще одного раза для каждого из объектов. А значит такая трансформация корректна.
	\item \mintinline{java}{noneMatch} -- Короткозамкнутая завершающая операция. Возвращает \mintinline{java}{true}, если все объекты в потоке не удовлетворяют переданному предикату, а в случае, когда хотя бы один удовлетворяет, то \mintinline{java}{false}.
	
	После выполнения этой операции будет полезно узнать, почему результат $false$. Это значит, что нужно узнать, для каких объектов предикат вернул $true$. 
	
	Покажет соответствующую трансформацию цепочки. Пусть исходная цепочка имеет вид:
	\inputminted{java}{chapter2/code/anyMatch.java}
	
	После трансформации она будет иметь следующий вид:
	
	\inputminted{java}{chapter2/code/anyMatchTransform.java}
	
	По аналогии с предыдущими операциями можно убедиться, что такая трансформация корректна.
\end{itemize}

На первый взгляд можно решить, что в операциях \mintinline{java}{allMatch/anyMatch/noneMatch} объект который нас интересует, это всегда последний элемент перед завершающей операцией. Но это не так, потому что короткозамкнутые операции не дают гарантий, что прочитают ровно столько элементов, сколько им достаточно. Они могут прочитать несколько больше. В текущей реализации это наблюдается, например, при использовании \mintinline{java}{flatMap} перед короткозамкнутой операцией. 
\inputminted{java}{chapter2/code/flatMapBeforeAnyMatch.java}
Данный вызов напечатает 123, хотя для завершения anyMatch достаточно только первого объекта. Поэтому необходимо усложнить способ нахождения таких объектов.

