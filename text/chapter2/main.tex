\section{Подход к решению задачи}
Прежде чем приступить к описанию решения, необходимо понять, какие гарантии предоставляет Stream API, а так же какие предположения можно делать о пользовательском коде.

\subsection{Гарантии Stream API}\label{java:guarantees}
Промежуточные операции всегда ленивые. Это значит, что операция не будет запрашивать следующий элемент, если может корректно вычислиться без его использования.
\begin{itemize}
	\item Это исключает ситуации, когда из каких-то промежуточных операций вынимались объекты, но затем не использовались.
	\item Но это не исключает, что некоторым промежуточным операциям потребуется прочитать более одного объекта, чтобы что-либо вычислить. (sorted, distinct)
	\item Следствие: нет вызова терминальной операции - нет вычислений.
\end{itemize}

\subsection{Требования к коду пользователя} \label{code:demands}

Кроме предоставления гарантий, Stream API делает предположения о коде пользователя. Соблюдение следующих требований снизит вероятность неожиданного поведения вызовов Stream API. Эти требования особенно критичны в случае использования параллельных потоков.

\begin{itemize}
	\item Операции над объектами не могут модифицировать объект-источник.
	\inputminted{java}{chapter2/code/SourceModification.java}
	\item Функции над объектами в потоке не должны иметь состояния (когда это возможно).
	\inputminted{java}{chapter2/code/StatefulOperation.java}
	\item Однажды созданный объект Stream может вызвать лишь одну терминальную операцию. Если это требование нарушено, то произойдет исключение.
	\inputminted{java}{chapter2/code/OneTermination.java}
\end{itemize}

\subsection{Параллельные потоки объектов}
\input{character2/parallel.tex}

\subsection{Определение подходящего вызова}
При отладке программ внутри среды разработки пользователь видит текущее положение программы относительно исходного кода и текущее состояние программы (локальные переменные, объекты и их поля, потоки, стек и другие). На самом деле виртуальная машина Java исполняет инструкции байт-кода и какие они в точности нам неизвестно. Можно считать, что есть какой-то способ их отображение на исходный код, который реализует среда разработки, благодаря которому мы можем говорить о текущее положении программы не в термах машинных комманд или java байт-кода, а в терминах исходного java кода. Поэтому далее под позицией отладчика будем понимать строку в исходном коде.

Прежде чем начать отладку цепочки Stream API необходимо определить её границы и понять достаточно ли данных для её вычисления.

В отладчике для каждого из потоков всегда определено текущее положение указателя инструкций. Определим подходящие положения этого указателя относительно вызова цепочки Stream API для того, чтобы начать её отладку. При вызове цепочки в ней могут участвовать объявленные ранее переменные и значения полей. Поэтому отлаживать вызов, который находится значительно позже чем текущая инструкция не имеет смысла (возможно, имеющихся данных будет недостаточно). Текущая строка отладчика отмечена стрелкой (=>).

\inputminted{java}{chapter2/code/FarToCall.java}

Если же все инструкции до вызова выполнены, значит все переменные и поля были инициализированы и можно начать его отладку. 

\inputminted{java}{chapter2/code/BeforeCall.java}

Начинать отладку можно и после начала, т.к. мы предположили, что вызов не имеет побочных эффектов, которые изменят окружение.
\inputminted{java}{chapter2/code/InEvaluation.java}

После того, как вызов завершен, он больше не подходит для отладки. Во-первых, может быть уже другой вызов, который подходит. Во-вторых окружение может измениться, изменив начальную семантику вызова.
\inputminted{java}{chapter2/code/AfterCall.java}

Таким образом, отладка допустима, если текущее положение отладчика между непосредственным начало вызова потока и до его завершения.

\subsubsection{Цепочки в других элементах стека вызовов}
При отладке пользователь может сменить элемент стека вызовов. В другом элементе стека позиция отладчика находится на вызове метода. Этот вызов может находиться внутри цепочки Stream API. А значит, такая цепочка подходит для отладки.
\inputminted{java}{chapter2/code/NestedMethod.java}

При переключении элемента стека в функцию \textbf{nestedExample} вызов Stream API внутри неё должен быть доступен для отладки.

\subsubsection{Неоднозначные вызовы}
Из одного и того же положения отладчика может быть доступно сразу несколько подходящих вызовов Stream API:
\begin{itemize}
	\item Внутри одного арифметического выражения;
	\inputminted{java}{chapter2/code/AmbiguousPlus.java}
	\item Аргументы некоторого вызова;
	\inputminted{java}{chapter2/code/AmbiguousArgs.java}
	\item Параметр другого вызова Stream API;
	\inputminted{java}{chapter2/code/AmbiguousNested.java}
	\item Вызов находится в объемлющем коде;
	\inputminted{java}{chapter2/code/AmbiguousLambda.java}
	\item В одной цепочке методов есть несколько последовательных цепочек с терминальной операцией;
	\inputminted{java}{chapter2/code/AmbiguousLinkedChains.java}
\end{itemize}
Все такие цепочки подходят для отладки.

\subsubsection{Незавершенные цепочки}\label{java:incomplete}
Согласно \ref{java:guarantees} цепочки методов Stream API без терминальной операции не вычисляются, значит и отлаживать их не нужно.

\subsubsection{Присваивание объекта потока в переменную}
Поскольку Stream API это просто набор классов, а не специальный синтаксис, то цепочки создают обычные объекты, с которыми можно обращаться как с любыми другими объектами. В этом контексте интерес представляет операция присваивания в переменную.
\inputminted{java}{chapter2/code/AssignToVariable.java}

Это вносит некоторые проблемы. Ранее мы рассматривали цепочке методов Stream API как нечто неделимое, но теперь видим, что это не так. Причем выражение, которое инициализирует переменную \mintinline{java}{even} без завершающей операции, а значит, это выражение нельзя отлаживать (см \ref{java:incomplete}).

С другой стороны, выражение \mintinline{java}{even.count()} нельзя запустить повторно.

Этот случай достаточно прост, и можно решить, что вы можем посмотреть как инициализируется переменная \mintinline{java}{even}. После чего объединить это выражение с терминальной операцией, получив 

\mintinline{java}{final long size = collection.stream().filter(x -> x % 2 == 0).count()}
	
Но это не решит всех наших проблем. Этот пример слишком прост, и на практике могут встретиться и более сложные случаи:
\inputminted{java}{chapter2/code/AssignToVariableHardCase.java}

В этом случае тем же способом уже не справиться (хотя этот случай выглядит более близким к практике). Поэтому для таких вызовов будем находить лишь ту часть, которая относится только к последней цепочке (с терминальной операцией). Заметим, что это инвалидирует поток в переменной even, поэтому об этому лучше предупреждать пользователя.

\subsection{Построение состояний и переходов}
В \ref{code:demands} описаны требования к коду пользователя, который использует Stream API. Эти требования позволяют сделать предположение, что вызов не имеет побочных эффектов и его можно повторить несколько раз, получив тот же самый результат.

Основная идея состоит в том, чтобы запустить вычисление модифицированного вызова Stream API, результат которого совпадет с исходным, при этом новая цепочка собирает информацию, полезную для процесса отладки.

\subsubsection{Выражение с отладочной информацией}


\subsubsection{Вычисление выражения}


\subsubsection{Интерпретация результата}

\subsection{Визуализация}
