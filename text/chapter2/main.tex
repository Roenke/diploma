\section{Подход к решению задачи}\label{chapter2}
Прежде чем приступить к описанию решения, необходимо понять, какие гарантии предоставляет Stream API, а так же какие предположения можно делать о пользовательском коде.

\subsection{Гарантии Stream API}\label{java:guarantees}
Промежуточные операции всегда ленивые. Это значит, что операция не будет запрашивать следующий элемент, если может корректно вычислиться без его использования.
\begin{itemize}
	\item Это исключает ситуации, когда из каких-то промежуточных операций вынимались объекты, но затем не использовались.
	\item Но это не исключает, что некоторым промежуточным операциям потребуется прочитать более одного объекта, чтобы что-либо вычислить. (sorted, distinct)
	\item Следствие: нет вызова терминальной операции - нет вычислений.
\end{itemize}

\subsection{Требования к коду пользователя} \label{code:demands}

Кроме предоставления гарантий, Stream API делает предположения о коде пользователя. Соблюдение следующих требований снизит вероятность неожиданного поведения вызовов Stream API. Эти требования особенно критичны в случае использования параллельных потоков.

\begin{itemize}
	\item Операции над объектами не могут модифицировать объект-источник.
	\inputminted{java}{chapter2/code/SourceModification.java}
	\item Функции над объектами в потоке не должны иметь состояния (когда это возможно).
	\inputminted{java}{chapter2/code/StatefulOperation.java}
	\item Однажды созданный объект Stream может вызвать лишь одну терминальную операцию. Если это требование нарушено, то произойдет исключение.
	\inputminted{java}{chapter2/code/OneTermination.java}
\end{itemize}

\subsection{Параллельные потоки объектов}
\input{character2/parallel.tex}

\subsection{Определение подходящего вызова}
При отладке программ внутри среды разработки пользователь видит текущее положение программы относительно исходного кода и текущее состояние программы (локальные переменные, объекты и их поля, потоки, стек и другие). Виртуальная машина Java исполняет инструкции байт-кода, заменяя их набором машинных команд. Машинные . Можно считать, что существует какой способ отображения инструкций байт-кода на исходный код, реализуемый средой разработки и благодаря которому, мы можем говорить о текущем положении программы не в термах машинных комманд или java байт-кода, а в терминах исходного java кода. Поэтому, под позицией отладчика будем понимать строку в исходном коде.

Прежде чем начать отладку цепочки Stream API необходимо определить её границы и понять достаточно ли данных для её вычисления.

В отладчике для каждого из потоков всегда определено текущее положение указателя инструкций. Определим подходящие положения этого указателя относительно вызова цепочки Stream API для того, чтобы начать её отладку. При вызове цепочки в ней могут участвовать объявленные ранее переменные и значения полей. Поэтому отлаживать вызов, который находится значительно позже чем текущая инструкция не имеет смысла (возможно, имеющихся данных будет недостаточно). Текущая строка отладчика отмечена стрелкой \mintinline{java}{=>}.

\inputminted{java}{chapter2/code/FarToCall.java}

Если же все инструкции до вызова выполнены, значит все переменные и поля были инициализированы и можно начать его отладку. 

\inputminted{java}{chapter2/code/BeforeCall.java}

Начинать отладку можно и после начала исполнения цепочки, т.к. мы предположили, что вызов не имеет побочных эффектов, которые изменят окружение.
\inputminted{java}{chapter2/code/InEvaluation.java}

После того, как вызов завершен, он больше не подходит для отладки. Во-первых, может быть уже другой вызов, который подходит. Во-вторых окружение может измениться, изменив начальную семантику вызова.
\inputminted{java}{chapter2/code/AfterCall.java}

В случае показанной на примере для отладки подходит уже следующая цепочка: \mintinline{java}{transformed.stream().forEach(x -> collection.add(x))}

Таким образом, отладка допустима, если текущее положение отладчика между непосредственным начало вызова потока и до его завершения.

\subsubsection{Цепочки в других элементах стека вызовов}
При отладке пользователь может сменить элемент стека вызовов. В другом элементе стека позиция отладчика находится на вызове метода. Этот вызов может находиться внутри цепочки Stream API. А значит, такая цепочка подходит для отладки.
\inputminted{java}{chapter2/code/NestedMethod.java}

При переключении элемента стека в функцию \textbf{nestedExample} вызов Stream API внутри неё должен быть доступен для отладки.

\subsubsection{Неоднозначные вызовы}
Из одного и того же положения отладчика может быть доступно сразу несколько подходящих вызовов Stream API:
\begin{itemize}
	\item Внутри одного арифметического выражения;
	\inputminted{java}{chapter2/code/AmbiguousPlus.java}
	\item Аргументы некоторого вызова;
	\inputminted{java}{chapter2/code/AmbiguousArgs.java}
	\item Параметр другого вызова Stream API;
	\inputminted{java}{chapter2/code/AmbiguousNested.java}
	\item Вызов находится в объемлющем коде;
	\inputminted{java}{chapter2/code/AmbiguousLambda.java}
	\item В одной цепочке методов есть несколько последовательных цепочек с терминальной операцией;
	\inputminted{java}{chapter2/code/AmbiguousLinkedChains.java}
\end{itemize}
Все такие цепочки подходят для отладки.

\subsubsection{Незавершенные цепочки}\label{java:incomplete}
Согласно \ref{java:guarantees} цепочки методов Stream API без терминальной операции не вычисляются, значит и отлаживать их не нужно.

\subsubsection{Присваивание объекта потока в переменную}
Поскольку Stream API это просто набор классов, а не специальный синтаксис, то цепочки создают обычные объекты, с которыми можно обращаться как с любыми другими объектами. В этом контексте интерес представляет операция присваивания в переменную.
\inputminted{java}{chapter2/code/AssignToVariable.java}

Это вносит некоторые проблемы. Ранее мы рассматривали цепочке методов Stream API как нечто неделимое, но теперь видим, что это не так. Причем выражение, которое инициализирует переменную \mintinline{java}{even} без завершающей операции, а значит, это выражение нельзя отлаживать (см \ref{java:incomplete}).

С другой стороны, выражение \mintinline{java}{even.count()} нельзя запустить повторно.

Этот случай достаточно прост, и можно решить, что вы можем посмотреть как инициализируется переменная \mintinline{java}{even}. После чего объединить это выражение с терминальной операцией, получив 

\mintinline{java}{final long size = collection.stream().filter(x -> x % 2 == 0).count()}
	
Но это не решит всех наших проблем. Этот пример слишком прост, и на практике могут встретиться и более сложные случаи:
\inputminted{java}{chapter2/code/AssignToVariableHardCase.java}

В этом случае тем же способом уже не справиться (хотя этот случай выглядит более близким к практике). Поэтому для таких вызовов будем находить лишь ту часть, которая относится только к последней цепочке (с терминальной операцией). Заметим, что это инвалидирует поток в переменной even, поэтому об этому лучше предупреждать пользователя.

\subsection{Построение состояний и переходов}
В \ref{code:demands} описаны требования к коду пользователя, который использует Stream API. Эти требования позволяют сделать предположение, что вызов не имеет побочных эффектов и его можно повторить несколько раз, получив тот же самый результат.

Основная идея состоит в том, чтобы запустить вычисление модифицированного вызова Stream API, результат которого совпадет с исходным, при этом новая цепочка собирает информацию, полезную для процесса отладки.

\subsubsection{Выражение для сбора отладочной информации}\label{build-expression}
Для того, чтобы собрать информацию о том, какие объекты проходили через поток можно использовать метод \mintinline{java}{peek}. Добавив такой вызов между каждой промежуточной операцией мы сможем найти какие объекты были внутри потока.

Рассмотрим пример:

Данный вызов возвращает список имен людей, чей возраст меньше 18 лет, упорядоченный по возрастанию.
\inputminted{java}{chapter2/code/StreaMWithoutPeeks.java}
При помощи метода \mintinline{java}{peek} можно наблюдать промежуточные состояния в потоке:
\inputminted{java}{chapter2/code/StreamWithPeeks.java}

Даже если мы будем просто печатать элементы в методе peek (с указанием где именно, то мы получим нечто полезное). Для некоторого списка людей вызов может напечатать следующее. В квадратных скобках указан возраст. 
\inputminted{java}{chapter2/code/peekResults.txt}

Заметим, что из такого вывода можно извлечь следующую информацию:
\begin{itemize}
	\item \textbf{Последовательность} прохождения объектов через цепочку вызовов. Напечатанные строки идут в порядке исполнения программы. Значит, сначала из источника был взят объект с \mintinline{java}{id = 1}, затем он прошел фильтрацию и попал в sorted, и так далее.
	\item \textbf{Результат фильтрации}. Можно увидеть все значения, которые прошли фильтрацию -- это ровно те значения, которые мы наблюдали после вызова \mintinline{java}{filter}.
	\item \textbf{Свойства вызовов.} Вызов sorted имеет состояние и требует выполнить весь поток до своего вызова. Поэтому пока объекты в источнике не закончились после вызова sorted ничего не происходило.
	\item \textbf{Множества } объектов до и после вызова. Обратим внимание, что мы печатаем положение метода peek, поэтому можно понять множества объектов, которые были до и после каждого из вызовов.
	\item \textbf{Преобразования} объектов. На примере вызова map, видно, что в последовательных событиях содержится преобразование -- извлечение имени человека: \mintinline{java}{{id = 1, name = Vasily, age = 10} => Vasily}
\end{itemize}

Приведенный лог выше плох тем, что он описывает поведение всего потока целикомЭ, а не каждого вызова в отдельности. Но для каждого вызова в цепочки можно оставить только зависи, которые были сделаны непосредственно до и после него. Таким образом получим два набора объектов -- до вызова и после него. Объекты в этих наборах можно упорядочить по времени появления в логе. 

То есть для каждого промежуточного вызова можем добавить 2 метода peek, которые соберут информацию об объектах, которые были до него и после него. Кроме того, добавим глобальное время, которое будет увеличиваться когда следующий элемент был запрошен у одного из исходных промежуточных объектов Stream.

\inputminted{java}{chapter2/code/LocalChainModification.java}

Таким образом, для вызова \mintinline{java}{call} будет два множества пар: 
\begin{equation*}
	L = \{t_i, obj_i\}, R = \{t_j, obj_j\}
\end{equation*}

Объекты полученные до вызова \mintinline{java}{call} обозначим $L$, а после \mintinline{java}{call} -- $R$

После этого нужно восстановить переходы между множествами $L$ и $R$, которые соответствуют вызову \mintinline{java}{call}.

\textbf{Прямым переходом} (TODO: эо отображение, а не переход) для элемента $l \in L$ называется множество $R' \subset R$ такое, что $\forall r \in R'$ объект $r$ является результатом воздействия операции \mintinline{java}{call} на элемент $l$.

По аналогии можно определить и \textbf{обратный переход}.
Правила, по которым строятся прямые и обратные отображения для конкретных вызовов описаны в \ref{interpret}.

Для большинства промежуточных операций множеств $L$ и $R$ достаточно для построения переходов. Единственное исключение -- промежуточная операция \mintinline{java}{distinct}. Решение для него предложим немного позже в TODO;

\subsubsection{Вычисление выражения}
При остановке на точках останова, отладчики сред разработки предоставляют возможность вычислять выражения на java. 

Существует 2 способа вычислить выражение. 
\begin{itemize}
	\item JDI. Java Debug Interface позволяет взаимодействовать с объектами на удаленной виртуальной машине при помощи объектов-посредников. Эти объекты позволяют узнать тип объекта, получить значение полей, вызывать методы, создать новый экземпляр, передать в качестве параметра в другой метод и другие. Зачастую для вычисления выражений хватает интерфейса JDI. Но не всегда -- отсутствуют возможности определять новые классы, а значит не позволяют в выражениях нельзя использовать синтаксис, приводящий к определению новых классов. Это ограничение запрещает использование анонимных классов и анонимных функций.
	\item Загрузка новых классов. Основным достоинством этого подхода является возможность определить новые классы, а значит -- в выражениях можно использовать анонимные классы и функции. Недостатком является то, что прежде чем загрузить класс, его нужно скомпилировать, а это влечет запуск компилятора и процесс компиляции. С другой стороны, после того как код загружен, он сможет исполняться быстрее чем с использованием JDI (нет накладных расходов на взаимодействие через объекты-посредники \ref{jdpa}).
\end{itemize}

\subsubsection{Интерпретация результата}\label{interpret}

Как мы сказали в \ref{build-expression} результатом выполнения выражения является набор множеств $L$ и $R$ для каждой промежуточной операции. Элементы этих множеств это пары $\{t_i, x_i\}$, $t_i$ -- это целое число, $x_i$ -- это соответствующий объект-посредник для объекта, который был на виртуальной машине, код на которой мы хотим отладить (см TODO). Будем считать, что элементы внутри множест $L$ и $R$ упорядочены по времени. Иными словами, $t_i < t_{i + 1}$. Рассмотрим правила построения переходов для каждого из промежуточных вызовов стандартной реализации Stream API.
\begin{itemize}
	\item \mintinline{java}{map} -- Это промежуточная операция без состояний -- она сразу же вернёт новый элемент потока. Таким образом для элемента $\{t_i, x_i\} = l \in L$, будет соответствовать в точности один элемент $\{t_j, y_j\} = r \in R$, такой, что $t_j = t_i + 1$. Таким образом, мы нашли переход $l <=> r$.
	\item \mintinline{java}{filter} -- У применения операции \mintinline{java}{filter} на элемент есть два исхода: он останется в потоке, либо будет отброшен. Если он останется, то сразу же вернется в поток. Это значит, что если объект $\{t_i, x_i\} = l \in L$ прошёл фильтрацию, следовательно найдется элемент $\{t_j, y_j\} = r \in R$, такой что $t_j = t_i + 1$. Если же условие не выполнилось, то в следующий момент исключена ситуация, когда описанный элемент $r$ будет в множестве $R$, т.к. операция \mintinline{java}{filter} не имеет состояния и не может выдать новый элемент, прежде чем прочитает следующий, а значит значение $t_j > t_i + 1$. 
	\item \mintinline{java}{flatMap} -- В результате применения flatMap один объект в потоке заменяется на 0 или больше новых объектов. Аналогично \mintinline{java}{filter}, воспользуемся тем, что \mintinline{java}{flatMap} не может считывать следующие значения, до тех пор, пока можно возвращать значения, соответствующие считанному в прошлый раз. Рассмотрим элемент $\{t_i, x_i\} = l \in L$, для которого мы хотим построить переходы. Далее возможны два случая.
	\begin{itemize}
		\item Существует элемент $\{t_{i + 1}, x_{i + 1}\} \in L$. Это значит, что элементы из $R$, которые соответствуют $l$ не могли появится раньше момента $t_i$, и не позже $t_{i + 1}$. Таким образом, получили переходы $l <=> r, \\ r \in \{\{t_j, x_j\} \in R : t_i < t_j < t_{i + 1}\}$.
		\item $l$ - последний в $L$. Аналогичные рассуждения, но $t_{i + 1} = +\infty$
	\end{itemize}
	\item \mintinline{java}{sorted} -- В результате применения операции sorted в потоке будут те же самые объекты, но уже в другом порядке. 
\end{itemize}

Выше перечислены методы для которых построение переходов различается. Для остальных вызовов можно использовать эти же алгоритмы, т.к. они в смысле переходов являются частным случаев описанных выше операций.
\begin{itemize}
	%linked
	\item \mintinline{java}{limit(k)} -- Частный случай \mintinline{java}{filter} -- фильтрацию прошли только первые $k$ элементов.
	\item \mintinline{java}{skip(k)} -- Частный случай \mintinline{java}{filter} -- первые $k$ элементов не прошли фильтрацию, а все остальные прошли.
	\item \mintinline{java}{peek} -- Частный случай \mintinline{java}{filter} -- все элементы прошли фильтрацию
	\item \mintinline{java}{onClose} -- Частный случай peek
	\item \mintinline{java}{flatMapToInt/flatMapToLong/flatMapToDouble} -- Частный случай \mintinline{java}{flatMap}
	\item \mintinline{java}{mapToInt/mapToLong/mapToDouble/mapToObj} -- Частный случай \mintinline{java}{map}
	\item \mintinline{java}{boxed} -- Частный случай \mintinline{java}{mapToObj}
\end{itemize}  


\subsubsection{Решение для операции distinct}
\mintinline{java}{distinct} -- промежуточная операция c состоянием, поэтому прежде чем что-то вернуть ей может понадобиться прочитать весь входной поток. Результатом является поток объектов, для которого гарантируется, что все объекты попарно различны (в смысле отношения \mintinline{java}{equals}\cite{java:equals}). Новых объектов при этом появиться не может.

Таким образом, в результате этого вызова из потока может исчезнуть часть объектов. Это операция является частным случаем операции \mintinline{java}{filter}: в ней так же часть элементов из потока будут отброшены. Но, в отличие от \mintinline{java}{filter} объекты обрабатываются не независимо друг от друга и причи. Для целей отладки будет полезным знание о том, почему эти объекты пропали. То есть нужно знать какие объекты равны друг другу. Но имея лишь множества объектов до операции и после него, а так же времена для них полностью восстановить эту информацию невозможно. Проблема возникает, когда объект был отфильтрован в результате вызова. Всё что мы можем о нем сказать, что он равен ровно одному объекту из тех, которые были после вызова. Но какому именно, сказать нельзя.

Для решение описанной проблемы используем следующий подход. В java операция equals должна удовлетворять отношению эквивалентности. Тогда множество объектов до \mintinline{java}{distinct} можно разбить на классы эквивалентности по \mintinline{java}{distinct}. 

Заметим, что объекты после \mintinline{java}{distinct} -- это представители каждого из этих классов. Таким образом, для того, чтобы построить переходы нужно взять объект $r$ после \mintinline{java}{distinct}, найти класс эквивалентности к которому он принадлежит, и для всех объектов $l$ из этого класса создать переходы $l <=> r$. 

\subsubsection{Переходы для завершающих операций}
Иногда может быть интересно узнать почему в результате выполнения цепочки вызовов получился тот или иной результат. Поэтому для операций, это можно понять при помощи переходов так же поставим задачу их построить.

Среди всех завершающих операций выделим несколько и для каждой из них опишем способ получения переходов:

\begin{itemize}
	\item \mintinline{java}{toArray} -- наиболее простая завершающая операция. Объекты, которые были в потоке до неё переходят в элементы массива, сохраняя порядок.
	\item \mintinline{java}{min/max/findFirst/findAny} -- вызовы, которые возвращают Optional \cite{java:optional}. Возможно сделать переход для объектов, которые равны содержимому Optional.
	\item \mintinline{java}{allMatch} -- Короткозамкнутая завершающая операция. Возвращает \mintinline{java}{true}, если все объекты в потоке удовлетворяют переданному предикату, иначе \mintinline{java}{false}. Если значение false, то для отладки будет полезно знать для каких объектов предикат не верен.
	
	Чтобы получить объекты, для которые предикат не верен, достаточно произвести описанную ниже трансформацию цепочки. Пусть исходная цепочка имеет вид:
	
	\mintinline{java}{source.stream()./* ops */.allMatch(predicate);}

	Новая цепочка:
	
	\inputminted{java}{chapter2/code/allMatchTransform.java}
	
	Все объекты, попавшие в метод peek, не прошли проверку \mintinline{java}{predicate}, а значит, нарушают условие \mintinline{java}{allMatch}. И результат вызова новой цепочки совпадает в результатом исходной, потому что если поток пуст, то вызов \\ \mintinline{java}{allMatch(x -> false)} вернёт \mintinline{java}{true}. Заметим, что предикат вызовется по одному разу для каждого объекта, как и в исходной цепочке.
	
	\item \mintinline{java}{anyMatch} -- Короткозамкнутая завершающая операция. Возвращает \mintinline{java}{true}, хотя бы один объект удовлетворяет переданному предикату, иначе \mintinline{java}{false}. Если значение оказалось true, то для целей отладки может быть полезно знать для каких объектов выполнился предикат.
	
	Чтобы найти эти объекты снова трансформируем цепочку, но уже немного иначе. Пусть исходная цепочка имеет следующий вид: 
	
	\inputminted{java}{chapter2/code/anyMatch.java}
	
	После трансформации она будет иметь следующий вид:
	
	\inputminted{java}{chapter2/code/anyMatchTransform.java}
	
	По аналогии с \mintinline{java}{allMatch} можно понять, что такая цепочки имеет тот же результат, позволяет найти интересующие объекты и вызывает \mintinline{java}{predicate} ровно для тех же самых объектов, причем делает это не чаще одного раза для каждого из объектов. А значит такая трансформация корректна.
	\item \mintinline{java}{noneMatch} -- Короткозамкнутая завершающая операция. Возвращает \mintinline{java}{true}, если все объекты в потоке не удовлетворяют переданному предикату, а в случае, когда хотя бы один удовлетворяет, то \mintinline{java}{false}.
	
	После выполнения этой операции будет полезно узнать, почему результат $false$. Это значит, что нужно узнать, для каких объектов предикат вернул $true$. 
	
	Покажет соответствующую трансформацию цепочки. Пусть исходная цепочка имеет вид:
	\inputminted{java}{chapter2/code/anyMatch.java}
	
	После трансформации она будет иметь следующий вид:
	
	\inputminted{java}{chapter2/code/anyMatchTransform.java}
	
	По аналогии с предыдущими операциями можно убедиться, что такая трансформация корректна.
\end{itemize}

На первый взгляд можно решить, что в операциях \mintinline{java}{allMatch/anyMatch/noneMatch} объект который нас интересует это всегда последний элемент, который был перед завершающей операцией. Но это не так, потому что короткозамкнутые операции не дают гарантий, что прочитают ровно столько элементов сколько им достаточно. Они могут прочитать несколько больше. В текущей реализации это наблюдается, например, при использовании \mintinline{java}{flatMap} перед короткозамкнутой операцией. 
\inputminted{java}{chapter2/code/flatMapBeforeAnyMatch.java}
Данный вызов напечатает 123, хотя для завершения anyMatch достаточно только первого объекта. Поэтому необходимо усложнить способ нахождения таких объектов.

