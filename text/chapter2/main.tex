\section{Подход к решению задачи}\label{chapter2}
Прежде чем приступить к описанию решения, необходимо понять, какие гарантии предоставляет Stream API, а так же какие предположения можно сделать о пользовательском коде.

\subsection{Гарантии Stream API}\label{java:guarantees}
Использование интерфейса потоков позволяет абстрагироваться от деталей часто используемых операций, описывая не то, \textbf{как} нужно делать операцию, а то, \textbf{что} должно быть сделано. Такой подход открывает большую свободу для внутренней реализации этих операций. Тем не менее, снаружи это должно всегда выглядеть одинаково и работать ожидаемо. Для этого существуют гарантии, которые должны выполняться для любой реализации интерфейса Stream. 

Основная гарантия предоставляемая Stream API, -- промежуточные операции всегда ленивые. Это значит, что операция не будет запрашивать следующий элемент, если может корректно вычислиться без его использования.
\begin{itemize}
	\item Это исключает ситуации, когда в промежуточных операциях из входного потока вынимались объекты, но затем не использовались.
	\item Но это не исключает, что некоторым промежуточным операциям потребуется прочитать более одного объекта, чтобы что-либо вычислить. (sorted, distinct)
	\item Следствие: нет вызова завершающей операции -- нет вычислений.
\end{itemize}

\subsection{Требования к коду пользователя} \label{code:demands}

Кроме предоставления гарантий, Stream API делает предположения о коде пользователя. Соблюдение следующих требований снизит вероятность неожиданного поведения вызовов Stream API. Эти требования особенно критичны в случае использования параллельных потоков.

\begin{itemize}
	\item Операции над объектами не могут модифицировать объект-источник.
	\inputminted{java}{chapter2/code/SourceModification.java}
	Исправленная версия:
	\inputminted{java}{chapter2/code/SourceModificationFixed.java}
	\item Функции над объектами в потоке не должны иметь состояния (когда это возможно).
	\inputminted{java}{chapter2/code/StatefulOperation.java}
	Исправленная версия:
	\inputminted{java}{chapter2/code/StatefulOperationFixed.java}
	\item Однажды созданный объект Stream может вызвать лишь одну терминальную операцию. Если это требование нарушено, то произойдет исключение.
	\inputminted{java}{chapter2/code/OneTermination.java}
	Исправленная версия:
	\inputminted{java}{chapter2/code/OneTerminationFixed.java}
\end{itemize}

\subsection{Параллельные потоки объектов}
\input{character2/parallel.tex}

\subsection{Определение подходящего вызова} \label{detection}
При отладке программ внутри среды разработки пользователь видит текущее положение программы относительно исходного кода и текущее состояние программы (локальные переменные, объекты и их поля, потоки, стек и другие). Виртуальная машина Java исполняет инструкции байт-кода, заменяя их набором машинных команд. Можно считать, что существует способ отображения инструкций байт-кода на исходный код, реализуемый средой разработки, и благодаря которому, мы можем говорить о текущем положении программы не в терминах машинных комманд или java байт-кода, а в терминах исходного java кода. Поэтому, под позицией отладчика будем понимать строку в исходном коде.

Прежде чем начать отладку цепочки Stream API, необходимо определить её границы и понять, достаточно ли данных для её вычисления.

В отладчике для каждого из потоков всегда определено текущее положение указателя инструкций.  Определим все положения указателя инструкций относительно цепочки Stream API, когда все необходимые данные для вычисления этой цепочки уже заданы.

При вызове цепочки в ней могут участвовать объявленные ранее переменные и значения полей. Таким образом, отлаживать вызов, который находится значительно позже, чем текущая инструкция, не имеет смысла (возможно, имеющихся данных будет недостаточно). Текущая строка отладчика отмечена стрелкой "\mintinline{java}{=>}". Интересующий нас вызов -- выражение, инициализирующее переменную \mintinline{java}{transformed}.

\inputminted{java}{chapter2/code/FarToCall.java}

Если же все инструкции до вызова выполнены, значит все переменные и поля были инициализированы и можно начать его отладку. 

\inputminted{java}{chapter2/code/BeforeCall.java}

Начинать отладку можно и после начала исполнения цепочки, т.к. мы предположили, что вызов не имеет побочных эффектов, которые изменят окружение.
\inputminted{java}{chapter2/code/InEvaluation.java}

После того, как вызов завершен, он больше не подходит для отладки, потому что окружение может измениться, изменив начальную семантику вызова. В примере ниже цепочка для инициализации переменной \mintinline{java}{transformed} больше не подходит для отладки -- её повторное исполнение приведет к другому результату, потому что переменная \mintinline{java}{limitValue} получила новое значение.
\inputminted{java}{chapter2/code/AfterCall.java}

Таким образом, отладка допустима, если текущее положение отладчика находится между непосредственным началом вызова потока и до его завершения.

\subsubsection{Цепочки в других элементах стека вызовов}
В процессе отладки пользователь может ставить точки останова внутри произвольных функций. После попадания на точку останова пользователь может изменять текущий элемент стека вызова. При переключении элемента стека изменяется и положение отладчика -- он будет находиться на вызове какого-либо метода. Ничего не мешает этому вызову находиться внутри цепочки Stream API. Вероятно, пользователь может захотеть запустить эту цепочку для отладки. И это должно быть возможно, т.к. согласно \ref{detection} отладчик находится внутри цепочки (просто несколькими уровнями выше по стеку вызовов), следовательно, такая цепочка подходит для отладки.
\inputminted{java}{chapter2/code/NestedMethod.java}

В примере выше отладчик попал в точку останова внутри метода \mintinline{java}{method}. Среди элементов на стеке вызовов будет метод \mintinline{java}{nestedExample}. При переключении отладчика на этот элемент, позиция отладчика будет установлена внутри тела метода \mintinline{java}{nestedExample}. На этой же строке находится и цепочка. Т.к. положение отладчика сейчас внутри цепочки, то она доступна для отладки.

\subsubsection{Неоднозначные вызовы}
Из одного и того же положения отладчика может быть доступно сразу несколько подходящих вызовов Stream API:
\begin{itemize}
	\item Внутри одного арифметического выражения;
	\inputminted{java}{chapter2/code/AmbiguousPlus.java}
	\item Аргументы некоторого вызова;
	\inputminted{java}{chapter2/code/AmbiguousArgs.java}
	\item Параметр другого вызова Stream API;
	\inputminted{java}{chapter2/code/AmbiguousNested.java}
	\item Вызов находится в объемлющем коде;
	\inputminted{java}{chapter2/code/AmbiguousLambda.java}
	\item В одной цепочке методов есть несколько последовательных цепочек с терминальной операцией;
	\inputminted{java}{chapter2/code/AmbiguousLinkedChains.java}
\end{itemize}
Все такие цепочки подходят для отладки и их необходимо уметь обнаруживать.

\subsubsection{Незавершенные цепочки}\label{java:incomplete}
Согласно \ref{java:guarantees} цепочки методов Stream API без терминальной операции не запускают вычисление, значит и отлаживать их не нужно.

\subsubsection{Присваивание объекта потока в переменную}
Поскольку Stream API это просто набор классов, а не специальный синтаксис, то цепочки создают обычные объекты, с которыми можно обращаться как с любыми другими объектами. В этом контексте интерес представляет операция присваивания в переменную.
\inputminted{java}{chapter2/code/AssignToVariable.java}

Ранее мы рассматривали цепочки методов Stream API,  как нечто неделимое, но теперь видим, что это не так. Причем выражение, инициализирующее переменную \mintinline{java}{even}, не содержит завершающей операции, а значит, это выражение нельзя отлаживать (см \ref{java:incomplete}).

С другой стороны, выражение \mintinline{java}{even.count()} нельзя запустить повторно.

Этот случай достаточно прост, и можно решить, что можно посмотреть, как инициализируется переменная \mintinline{java}{even}, затем объединить инициализацию с терминальной операцией, получив цепочку с завершающей операцией, не упустив промежуточные:

\mintinline{java}{final long size = collection.stream().filter(x -> x % 2 == 0).count()}
	
Но в общем случае это решение не сработает. Этот пример слишком прост, и на практике могут встретиться и более сложные случаи:
\inputminted{java}{chapter2/code/AssignToVariableHardCase.java}

В этом случае тем же способом уже не справиться (хотя этот случай выглядит более близким к практике). Поэтому для таких вызовов будем находить лишь ту часть, которая относится только к последней части цепочки (с терминальной операцией). Заметим, что это инвалидирует поток в переменной even, поэтому лучше предупреждать об этом пользователя.

\subsection{Построение состояний и переходов} \label{state-transitions-build}
В \ref{code:demands} описаны требования к коду пользователя, который использует Stream API. Эти требования позволяют сделать предположение, что вызов не имеет побочных эффектов и его можно повторить несколько раз, получив тот же самый результат.

Основная идея состоит в том, чтобы запустить вычисление модифицированного вызова Stream API, результат которого совпадет с исходным, при этом новая цепочка собирает полезную для отладки информацию.

\subsubsection{Выражение для сбора отладочной информации}\label{build-expression}
Для того, чтобы собрать информацию о том, какие объекты проходили через поток, можно использовать метод \mintinline{java}{peek}. Добавив такой вызов между каждой промежуточной операцией, мы сможем найти какие объекты были внутри потока.

Рассмотрим пример, показанный в \ref{ho-functions}:

\inputminted{java}{chapter2/code/StreaMWithoutPeeks.java}
При помощи метода \mintinline{java}{peek} можно наблюдать промежуточные состояния в потоке:
\inputminted{java}{chapter2/code/StreamWithPeeks.java}

Если мы будем просто печатать элементы в методе peek (с указанием где именно), то получим результат, из которого можно извлечь некоторую информацию. Для списка из пяти человек, данный вызов напечатает следующее:
\inputminted{java}{chapter2/code/peekResults.txt}

Заметим, что из такого вывода можно понять следующее:
\begin{itemize}
	\item \textbf{Последовательность} прохождения объектов через цепочку вызовов. Напечатанные строки идут в порядке исполнения программы. Сначала из источника был взят объект с \mintinline{java}{id = 1}, затем он прошел фильтрацию и попал в sorted, и так далее.
	\item \textbf{Результат фильтрации}. Можно увидеть все значения, которые прошли фильтрацию -- это ровно те значения, которые мы наблюдали после вызова \mintinline{java}{filter}.
	\item \textbf{Свойства вызовов.} Вызов \mintinline{java}{sorted} имеет состояние и требует выполнить весь поток до своего вызова. Поэтому, пока объекты в источнике не закончились, в потоке после вызова \mintinline{java}{sorted} объектов не было.
	\item \textbf{Множества } объектов до и после вызова. Обратим внимание, что мы печатаем положение метода peek, поэтому можно определить содержимое множеств объектов, которые были до и после каждого из вызовов.
	\item \textbf{Преобразования} объектов. На примере вызова map, видно, что в последовательных событиях содержится преобразование -- извлечение имени человека: \mintinline{java}{{id = 1, name = Vasily, age = 10} => Vasily}
\end{itemize}

Приведенный лог плох тем, что он описывает поведение всего потока целиком, а не каждого вызова в отдельности. Этот недостаток легко исправить: для каждой операции в цепочке можем рассмотреть только те записи, которые сделаны непосредственно до и сразу после этой операции. Таким образом, получим два набора объектов. Объекты в этих наборах можно упорядочить по времени появления в логе. Будем называть эти упорядоченные множества \textbf{состояниями} потока до и после промежуточной операции. 

Чтобы построить эти состояния, достаточно добавить метод \mintinline{java}{peek} между всеми операциями в потоке. Задача добавленных \mintinline{java}{peek}'ов -- сохранить объект, который в него пришел. Кроме того, добавим глобальное время, которое будет увеличиваться, когда следующий элемент будет запрошен у одного из исходных промежуточных объектов Stream. Момент времени, в который наблюдается объект в методе peek -- уникальный идентификатор для этого объекта в рамках данного запуска цепочки. Это позволит различать одинаковые объекты, которые могут встретиться в потоке.

\inputminted{java}{chapter2/code/LocalChainModification.java}

Таким образом, для вызова \mintinline{java}{call} мы сможем составить состояние потока до него и после него:
\begin{equation*}
	L = \{(t_i, obj_i)\}, R = \{(t_j, obj_j)\}
\end{equation*}

Первый элемент пары -- момент времени, в который наблюдается объект. Второй элемент пары -- наблюдаемый объект. Такие пары, полученные до операции \mintinline{java}{call}, обозначим $L$, а после \mintinline{java}{call} -- $R$

После этого нужно восстановить связи между элементами множеств $L$ и $R$. Для удобства описания следующих алгоритмов введем проекции для элементов множеств $L$ и $R$. Пусть $x = (t, obj)$ элемент одного из этих множеств, тогда проекции задаются правилами:
\begin{align*}
	time(x) &= t \\
	object(x) &= obj
\end{align*}

Множеством \textbf{переходов} будем называть множество $T \subset L \times R$. Элемент этого множества $(l, r), $ где $l \in L, r \in R$ несет следующую информацию: элемент потока $r$ является результатом воздействия операции \mintinline{java}{call} на элемент $l$.

Для большинства промежуточных операций множеств $L$ и $R$ достаточно для построения переходов. Единственное исключение -- промежуточная операция \mintinline{java}{distinct}. Решение для него предложим немного позже в \ref{distinct}.

Таким образом нам удалось локализовать задачу поиска переходов для объектов внутри потока. Вместо того, чтобы пытаться отследить путь объекта через весь поток, мы получили задачу восстановления переходов для промежуточных вызовов по-отдельности. Эта задача имеет решение абсолютно для всех промежуточных вызовов, которые есть в стандартной реализации. Разрешив переходы для всех промежуточных операций, можно последовательно восстановить историю объекта уже внутри целого потока. Это даст удобный способ понять, как объект попал в любую часть потока, а значит, появится возможность быстрее понять, что именно работает не так, как ожидается.
\subsubsection{Вычисление выражения} \label{code-evaluation}
Выше мы получили формальную постановку задачи. Для решения этой задачи на практике нам нужно иметь возможность построить множества $L$ и $R$. Для этого нам достаточно уметь вычислять модифицированную цепочку (после добавления методов \mintinline{java}{peek} и возможно каких-либо других методов, которые не влияют на итоговый результат).

При попадании на точку останова, отладчики сред разработки предоставляют возможность вычислять выражения на java.

Существует 2 способа вычислить выражение. 
\begin{itemize}
	\item JDI. Java Debug Interface позволяет взаимодействовать с объектами на удаленной виртуальной машине при помощи объектов-посредников (см \ref{jdpa}). Эти объекты позволяют узнать тип объекта, получить значение полей, вызывать методы, создать новый экземпляр, передать в качестве параметра в другой метод и другие. Зачастую для вычисления выражений хватает интерфейса JDI. Но не всегда: в JDI отсутствует возможность определять новые классы, Это значит, что в выражениях нельзя использовать синтаксис, приводящий к определению новых классов. Это ограничение запрещает использование анонимных классов и анонимных функций.
	\item Загрузка новых классов. Основным достоинством этого подхода является возможность определить новые классы, а значит -- в выражениях можно использовать анонимные классы и функции. Недостатком является то, что прежде чем загрузить класс, его нужно скомпилировать и загрузить. С другой стороны, после того как код загружен, он сможет исполняться быстрее, чем с использованием JDI (нет накладных расходов на взаимодействие через объекты-посредники \ref{jdpa}). Этот способ лучше подходит для вычислительно сложных выражений.
\end{itemize}

В нашем случае, большинство промежуточных операций принимают параметр, который может быть анонимным классом, либо анонимной функцией. Это не позволяет использовать первый способ, поэтому у нас нет выбора и будем использовать второй.

\subsubsection{Интерпретация результата}\label{interpret}

Как мы сказали в \ref{build-expression}, результатом выполнения выражения является набор множеств $L$ и $R$ для каждой промежуточной операции. Элементы этих множеств это пары $\{t_i, x_i\}$, где $t_i$ -- это целое число, $x_i$ -- это соответствующий объект-посредник для объекта, который находится на виртуальной машине, исполняющей отлаживаемую программу(см \ref{jdpa}). Будем считать, что элементы внутри множеств $L$ и $R$ упорядочены по времени. Иными словами, $t_i < t_{i + 1}$. Рассмотрим правила построения переходов для каждого из промежуточных вызовов стандартной реализации Stream API.
\begin{itemize}
	\item \mintinline{java}{map} -- промежуточная операция без состояния -- она сразу же вернёт новый элемент потока. Таким образом для элемента $\{t_i, x_i\} = l \in L$, будет соответствовать в точности один элемент $\{t_j, y_j\} = r \in R$, такой, что $t_j = t_i + 1$. Таким образом, мы нашли переход $(l, r)$. Всего таких переходов ровно $|L|$.
	\item \mintinline{java}{filter} -- промежуточная операция без состояния. У применения предиката операции \mintinline{java}{filter} на элемент есть два исхода: он останется в потоке, либо будет отброшен. Если он останется, то сразу же вернется в поток. Это значит, что если объект $\{t_i, x_i\} = l \in L$ прошёл фильтрацию, следовательно найдется элемент $\{t_j, y_j\} = r \in R$, такой что $t_j = t_i + 1$, и элементы $l$ и $r$ образуют переход $(l, r)$ для этой операции. Если же условие не выполнилось, то в следующий момент исключена ситуация, когда описанный элемент $r$ будет в множестве $R$, т.к. операция \mintinline{java}{filter} не имеет состояния и не может выдать новый элемент, прежде чем прочитает следующий, а значит значение $t_j > t_i + 1$. 
	
	Очевидно, что количество переходов для операции \mintinline{java}{filter} не превышает $|L|$, т.к. для каждого элемента из $L$ может быть не более одного перехода.
	\item \mintinline{java}{flatMap} -- промежуточная операция без состояния. В результате применения \mintinline{java}{flatMap}, один объект в потоке заменяется на 0 или более новых объектов. По аналогии с решением для \mintinline{java}{filter}, воспользуемся тем, что \mintinline{java}{flatMap} не может считывать следующие значения, до тех пор, пока можно возвращать значения, соответствующие считанному в прошлый раз. Рассмотрим элемент $\{t_i, x_i\} = l \in L$, для которого мы хотим построить переходы. Далее возможны два случая.
	\begin{itemize}
		\item Существует элемент $\{t_{i + 1}, x_{i + 1}\} \in L$. Это значит, что элементы из $R$, которые соответствуют $l$, не могли появится раньше момента $t_i$, и не позже $t_{i + 1}$. Таким образом, получили переходы $(l, r), \\ r \in \{\{t_j, x_j\} \in R : t_i < t_j < t_{i + 1}\}$.
		\item $l $ -- последний в $L$. Нужно построить переходы $(l, r), \ \forall r \in \{\{t_j, x_j\} \in R : t_i < t_j\}$
	\end{itemize}

	Для каждого элемента из $R$ может быть не более одного перехода. Поэтому количество переходов для этого вызова не более $|R|$.
	\item \mintinline{java}{sorted} -- промежуточная операция c состоянием. В результате применения операции sorted в потоке остаются те же самые объекты, но изменяется их порядок. Множество переходов в этом случае $T = \{(l, r)\} = \{(\{t_i, obj\}, \{t_j, obj\})\}$. То есть пары, в которых совпадают объекты, но значения момента времени, в которые объект наблюдался в потоке, различны. В случае, если в потоке были идентичные объекты (для которых верно, что \mintinline{java}{obj1 == obj2}), нужно добавить ограничение, что каждый элемент из множества $L$ входит ровно в один переход в $T$. Аналогичное ограничение верно и для элементов множества $R$.
	
	Количество переходов для этой операции в точности равно $|L| = |R|$
\end{itemize}

Выше перечислены методы, для которых построение переходов различается. Для остальных вызовов можно использовать эти же алгоритмы, т.к. они в смысле переходов являются частным случаев описанных выше операций.
\begin{itemize}
	%linked
	\item \mintinline{java}{limit(k)} -- частный случай \mintinline{java}{filter} -- фильтрацию прошли только первые $k$ элементов;
	\item \mintinline{java}{skip(k)} -- частный случай \mintinline{java}{filter} -- первые $k$ элементов не прошли фильтрацию, а все остальные прошли;
	\item \mintinline{java}{peek} -- частный случай \mintinline{java}{filter} -- все элементы прошли фильтрацию;
	\item \mintinline{java}{onClose} -- частный случай peek;
	\item \mintinline{java}{flatMapToInt/flatMapToLong/flatMapToDouble} --частный случай \mintinline{java}{flatMap};
	\item \mintinline{java}{mapToInt/mapToLong/mapToDouble/mapToObj} -- частный случай \mintinline{java}{map};
	\item \mintinline{java}{boxed} -- частный случай \mintinline{java}{mapToObj}.
\end{itemize}  

Заметим, что для всех рассмотренных операций размер множества переходов не превосходит $\max(|L|, |R|)$, поэтому при реализации нужно стремиться к линейной сложности (от размеров множеств $L$ и $R$) алгоритмов построения переходов.

\subsubsection{Решение для операции distinct}\label{distinct}
\mintinline{java}{distinct} -- промежуточная операция c состоянием, поэтому прежде чем что-либо вернуть, ей может понадобиться прочитать весь входной поток. Результатом является поток объектов, для которого гарантируется, что все объекты попарно различны (в отношении \mintinline{java}{equals}\cite{java:equals}). Новых объектов при этом появиться не может.

На первый взгляд, эта операция является частным случаем операции \mintinline{java}{filter}: в ней так же часть элементов из потока будет отброшена. Но в отличие от \mintinline{java}{filter} объекты обрабатываются не независимо друг от друга, поэтому рассуждения, представленные в \ref{interpret} могут лишь помочь увидеть, какие элементы прошли дальше, но узнать причины, по которым другие были отброшены, не удастся. Для установления этих причин необходимо узнать, какие объекты равны друг другу. Но имея лишь состояния потока до и после операции \mintinline{java}{distinct}, восстановить эту информацию невозможно. Проблема возникает, когда объект был отфильтрован в результате вызова. Всё, что мы можем сказать о данном объекте, -- он равен ровно одному объекту из тех, которые были после вызова. Но какому именно, сказать нельзя. (Решение попарно сравнить все объекты нам не подходит, т.к. оно квадратичное, и приведет к вызову методов через объекты-обертки, а значит к дополнительным накладным расходам на передачу данных между виртуальными машинами \ref{jdpa}).

Для решения описанной проблемы используем следующий подход. В java операция equals должна удовлетворять отношению эквивалентности. Тогда множество объектов $L$ можно разбить на классы эквивалентности по \mintinline{java}{equals} для объектов $object(l), l \in L$ на непересекающиеся множества $L_1, L_2, .., L_k$. Для этого будем использовать \\ \mintinline{java}{HashMap<Object, List<Ojbect>>}. У этой структуры данных есть свойство -- все её ключи попарно различны. Ключами данного отображения будут объекты перед вызовом \mintinline{java}{distinct}, а значениями -- списки объектов, равных между собой. То есть для каждого объекта $x \in \{object(l): l \in L\}$ нужно получить соответвующий список (при помощи \mintinline{java}{computeIfAbsent(x, key -> new ArrayList())}), затем добавить \mintinline{java}{x} в конец списка. Сложность описанного алгоритма $O(|L|)$ в среднем.

Заметим, что объекты в множестве $R$ -- это, согласно семантике \mintinline{java}{distinct}, представители каждого из классов эквивалентности. Таким образом, для того, чтобы построить переходы, нужно взять объект $r \in R$, найти класс эквивалентности $L_i$, к которому он принадлежит, и добавить переходы $(l, r) \ \forall l \in L_i$. 

\subsubsection{Переходы для завершающих операций}
Иногда может быть интересно узнать, почему в результате выполнения цепочки вызовов получился тот или иной результат. Для некоторых операций это можно понять при помощи переходов к результирующему значению, либо к его полям/содержимому. Поставим задачу найти такие переходы.

Для следующих завершающих операций можно получить дополнительную информацию при помощи переходов. Опишем для каждой из них способ нахождения множества переходов:

\begin{itemize}
	\item \mintinline{java}{toArray} -- наиболее простая завершающая операция. Объекты потока становятся элементами результирующего массива, сохраняя свой порядок.
	\item \mintinline{java}{min/max/findFirst/findAny} -- вызовы, которые возвращают Optional \cite{java:optional}. Возможно сделать переход для объектов, которые равны содержимому Optional.
	\item \mintinline{java}{allMatch} -- короткозамкнутая завершающая операция. Возвращает \mintinline{java}{true}, если все объекты в потоке удовлетворяют переданному предикату, иначе \mintinline{java}{false}. Если в результате получили значение \mintinline{java}{false}, то при отладке полезно знать, для каких объектов предикат не верен.
	
	Чтобы получить объекты, для которые предикат не верен, достаточно произвести описанную ниже трансформацию цепочки. Пусть исходная цепочка имеет вид:
	
	\mintinline{java}{source.stream()./* ops */.allMatch(predicate);}

	После трансформации она будет иметь следующий вид:
	
	\inputminted{java}{chapter2/code/allMatchTransform.java}
	
	Все объекты, попавшие в метод peek, не прошли проверку \mintinline{java}{predicate}, а значит, нарушают условие \mintinline{java}{allMatch}. Результат вызова новой цепочки совпадает с результатом исходной, потому что, если поток пуст, то вызов \\ \mintinline{java}{allMatch(x -> false)} вернёт \mintinline{java}{true}. Заметим, что предикат вызовется по одному разу для каждого объекта, как и в исходной цепочке.
	
	\item \mintinline{java}{anyMatch} -- Короткозамкнутая завершающая операция. Возвращает \mintinline{java}{true}, если хотя бы один объект удовлетворяет переданному предикату, иначе \mintinline{java}{false}. Если значение оказалось true, то для целей отладки может быть полезно знать для каких объектов выполнился предикат.
	
	Чтобы найти эти объекты, снова трансформируем цепочку, но уже немного иначе. Пусть исходная цепочка имеет следующий вид: 
	
	\inputminted{java}{chapter2/code/anyMatch.java}
	
	После трансформации она будет иметь следующий вид:
	
	\inputminted{java}{chapter2/code/anyMatchTransform.java}
	
	По аналогии с \mintinline{java}{allMatch}, можно понять, что такая цепочка имеет тот же результат, позволяет найти интересующие объекты и вызывает \mintinline{java}{predicate} ровно для тех же самых объектов, причем делает это не чаще одного раза для каждого из объектов. А значит, такая трансформация корректна.
	\item \mintinline{java}{noneMatch} -- Короткозамкнутая завершающая операция. Возвращает \mintinline{java}{true}, если все объекты в потоке не удовлетворяют переданному предикату, а в случае, когда хотя бы один удовлетворяет, \mintinline{java}{false}.
	
	После выполнения этой операции полезно узнать, почему результат $false$. Это значит, что нужно узнать, для каких объектов предикат вернул $true$. 
	
	Покажем соответствующую трансформацию цепочки. Пусть исходная цепочка имеет вид:
	\inputminted{java}{chapter2/code/noneMatch.java}
	
	После трансформации она будет иметь следующий вид:
	
	\inputminted{java}{chapter2/code/noneMatchTransform.java}
	
	По аналогии с предыдущими операциями можно убедиться, что такая трансформация корректна.
\end{itemize}

На первый взгляд может показаться, что в операциях \mintinline{java}{allMatch/anyMatch/noneMatch} интересующий нас объект - это всегда последний элемент перед завершающей операцией. Но это не так, потому что короткозамкнутые операции не дают гарантий, что прочитают ровно столько элементов, сколько им достаточно -- они могут прочитать больше. В текущей реализации это наблюдается, например, при использовании \mintinline{java}{flatMap} перед короткозамкнутой операцией. 
\inputminted{java}{chapter2/code/flatMapBeforeAnyMatch.java}
Данный вызов напечатает 123, хотя для завершения anyMatch достаточно только первого объекта. Описанный выше подход корректно справится с этой особенностью -- он строит переход \mintinline{java}{(1, true)}. Наивный алгоритм предложит неверный переход \mintinline{java}{(3, true)}.

