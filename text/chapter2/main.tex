\section{Подход к решению задачи}
Прежде чем приступить к описанию решения, необходимо понять, какие гарантии предоставляет Stream API, а так же какие предположения можно делать о пользовательском коде.

\subsection{Гарантии Stream API}\label{java:guarantees}
Промежуточные операции всегда ленивые. Это значит, что операция не будет запрашивать следующий элемент, если может корректно вычислиться без его использования.
\begin{itemize}
	\item Это исключает ситуации, когда из каких-то промежуточных операций вынимались объекты, но затем не использовались.
	\item Но это не исключает, что некоторым промежуточным операциям потребуется прочитать более одного объекта, чтобы что-либо вычислить. (sorted, distinct)
	\item Следствие: нет вызова терминальной операции - нет вычислений.
\end{itemize}

\subsection{Требования к коду пользователя} \label{code:demands}

Кроме предоставления гарантий, Stream API делает предположения о коде пользователя. Соблюдение следующих требований снизит вероятность неожиданного поведения вызовов Stream API. Эти требования особенно критичны в случае использования параллельных потоков.

\begin{itemize}
	\item Операции над объектами не могут модифицировать объект-источник.
	\inputminted{java}{chapter2/code/SourceModification.java}
	\item Функции над объектами в потоке не должны иметь состояния (когда это возможно).
	\inputminted{java}{chapter2/code/StatefulOperation.java}
	\item Однажды созданный объект Stream может вызвать лишь одну терминальную операцию. Если это требование нарушено, то произойдет исключение.
	\inputminted{java}{chapter2/code/OneTermination.java}
\end{itemize}

\subsection{Параллельные потоки объектов}
\input{character2/parallel.tex}

\subsection{Определение подходящего вызова}
При отладке программ внутри среды разработки пользователь видит текущее положение программы относительно исходного кода и текущее состояние программы (локальные переменные, объекты и их поля, потоки, стек и другие). На самом деле виртуальная машина Java исполняет инструкции байт-кода и какие они в точности нам неизвестно. Можно считать, что есть какой-то способ их отображение на исходный код, который реализует среда разработки, благодаря которому мы можем говорить о текущее положении программы не в термах машинных комманд или java байт-кода, а в терминах исходного java кода. Поэтому далее под позицией отладчика будем понимать строку в исходном коде.

Прежде чем начать отладку цепочки Stream API необходимо определить её границы и понять достаточно ли данных для её вычисления.

В отладчике для каждого из потоков всегда определено текущее положение указателя инструкций. Определим подходящие положения этого указателя относительно вызова цепочки Stream API для того, чтобы начать её отладку. При вызове цепочки в ней могут участвовать объявленные ранее переменные и значения полей. Поэтому отлаживать вызов, который находится значительно позже чем текущая инструкция не имеет смысла (возможно, имеющихся данных будет недостаточно). Текущая строка отладчика отмечена стрелкой (=>).

\inputminted{java}{chapter2/code/FarToCall.java}

Если же все инструкции до вызова выполнены, значит все переменные и поля были инициализированы и можно начать его отладку. 

\inputminted{java}{chapter2/code/BeforeCall.java}

Начинать отладку можно и после начала, т.к. мы предположили, что вызов не имеет побочных эффектов, которые изменят окружение.
\inputminted{java}{chapter2/code/InEvaluation.java}

После того, как вызов завершен, он больше не подходит для отладки. Во-первых, может быть уже другой вызов, который подходит. Во-вторых окружение может измениться, изменив начальную семантику вызова.
\inputminted{java}{chapter2/code/AfterCall.java}

Таким образом, отладка допустима, если текущее положение отладчика между непосредственным начало вызова потока и до его завершения.

\subsubsection{Цепочки в других элементах стека вызовов}
При отладке пользователь может сменить элемент стека вызовов. В другом элементе стека позиция отладчика находится на вызове метода. Этот вызов может находиться внутри цепочки Stream API. А значит, такая цепочка подходит для отладки.
\inputminted{java}{chapter2/code/NestedMethod.java}

При переключении элемента стека в функцию \textbf{nestedExample} вызов Stream API внутри неё должен быть доступен для отладки.

\subsubsection{Неоднозначные вызовы}
Из одного и того же положения отладчика может быть доступно сразу несколько подходящих вызовов Stream API:
\begin{itemize}
	\item Внутри одного арифметического выражения;
	\inputminted{java}{chapter2/code/AmbiguousPlus.java}
	\item Аргументы некоторого вызова;
	\inputminted{java}{chapter2/code/AmbiguousArgs.java}
	\item Параметр другого вызова Stream API;
	\inputminted{java}{chapter2/code/AmbiguousNested.java}
	\item Вызов находится в объемлющем коде;
	\inputminted{java}{chapter2/code/AmbiguousLambda.java}
	\item В одной цепочке методов есть несколько последовательных цепочек с терминальной операцией;
	\inputminted{java}{chapter2/code/AmbiguousLinkedChains.java}
\end{itemize}
Все такие цепочки подходят для отладки.

\subsubsection{Незавершенные цепочки}\label{java:incomplete}
Согласно \ref{java:guarantees} цепочки методов Stream API без терминальной операции не вычисляются, значит и отлаживать их не нужно.

\subsubsection{Присваивание объекта потока в переменную}
Поскольку Stream API это просто набор классов, а не специальный синтаксис, то цепочки создают обычные объекты, с которыми можно обращаться как с любыми другими объектами. В этом контексте интерес представляет операция присваивания в переменную.
\inputminted{java}{chapter2/code/AssignToVariable.java}

Это вносит некоторые проблемы. Ранее мы рассматривали цепочке методов Stream API как нечто неделимое, но теперь видим, что это не так. Причем выражение, которое инициализирует переменную \mintinline{java}{even} без завершающей операции, а значит, это выражение нельзя отлаживать (см \ref{java:incomplete}).

С другой стороны, выражение \mintinline{java}{even.count()} нельзя запустить повторно.

Этот случай достаточно прост, и можно решить, что вы можем посмотреть как инициализируется переменная \mintinline{java}{even}. После чего объединить это выражение с терминальной операцией, получив 

\mintinline{java}{final long size = collection.stream().filter(x -> x % 2 == 0).count()}
	
Но это не решит всех наших проблем. Этот пример слишком прост, и на практике могут встретиться и более сложные случаи:
\inputminted{java}{chapter2/code/AssignToVariableHardCase.java}

В этом случае тем же способом уже не справиться (хотя этот случай выглядит более близким к практике). Поэтому для таких вызовов будем находить лишь ту часть, которая относится только к последней цепочке (с терминальной операцией). Заметим, что это инвалидирует поток в переменной even, поэтому об этому лучше предупреждать пользователя.

\subsection{Построение состояний и переходов}
В \ref{code:demands} описаны требования к коду пользователя, который использует Stream API. Эти требования позволяют сделать предположение, что вызов не имеет побочных эффектов и его можно повторить несколько раз, получив тот же самый результат.

Основная идея состоит в том, чтобы запустить вычисление модифицированного вызова Stream API, результат которого совпадет с исходным, при этом новая цепочка собирает информацию, полезную для процесса отладки.

\subsubsection{Выражение для сбора отладочной информации}\label{build-expression}
Для того, чтобы собрать информацию о том, какие объекты проходили через поток можно использовать метод \mintinline{java}{peek}. Добавив такой вызов между каждой промежуточной операцией мы сможем найти какие объекты были внутри потока.

Рассмотрим пример:

Данный вызов возвращает список имен людей, чей возраст меньше 18 лет, упорядоченный по возрастанию.
\inputminted{java}{chapter2/code/StreaMWithoutPeeks.java}
При помощи метода \mintinline{java}{peek} можно наблюдать промежуточные состояния в потоке:
\inputminted{java}{chapter2/code/StreamWithPeeks.java}

Даже если мы будем просто печатать элементы в методе peek (с указанием где именно, то мы получим нечто полезное). Для некоторого списка людей вызов может напечатать следующее. В квадратных скобках указан возраст. 
\inputminted{java}{chapter2/code/peekResults.txt}

Заметим, что из такого вывода можно извлечь следующую информацию:
\begin{itemize}
	\item \textbf{Последовательность} прохождения объектов через цепочку вызовов. Напечатанные строки идут в порядке исполнения программы. Значит, сначала из источника был взят объект с \mintinline{java}{id = 1}, затем он прошел фильтрацию и попал в sorted, и так далее.
	\item \textbf{Результат фильтрации}. Можно увидеть все значения, которые прошли фильтрацию -- это ровно те значения, которые мы наблюдали после вызова \mintinline{java}{filter}.
	\item \textbf{Свойства вызовов.} Вызов sorted имеет состояние и требует выполнить весь поток до своего вызова. Поэтому пока объекты в источнике не закончились после вызова sorted ничего не происходило.
	\item \textbf{Множества } объектов до и после вызова. Обратим внимание, что мы печатаем положение метода peek, поэтому можно понять множества объектов, которые были до и после каждого из вызовов.
	\item \textbf{Преобразования} объектов. На примере вызова map, видно, что в последовательных событиях содержится преобразование -- извлечение имени человека: \mintinline{java}{{id = 1, name = Vasily, age = 10} => Vasily}
\end{itemize}

Приведенный лог выше плох тем, что он описывает поведение всего потока целикомЭ, а не каждого вызова в отдельности. Но для каждого вызова в цепочки можно оставить только зависи, которые были сделаны непосредственно до и после него. Таким образом получим два набора объектов -- до вызова и после него. Объекты в этих наборах можно упорядочить по времени появления в логе. 

То есть для каждого промежуточного вызова можем добавить 2 метода peek, которые соберут информацию об объектах, которые были до него и после него. Кроме того, добавим глобальное время, которое будет увеличиваться когда следующий элемент был запрошен у одного из исходных промежуточных объектов Stream.

\inputminted{java}{chapter2/code/LocalChainModification.java}

Таким образом, для вызова \mintinline{java}{call} будет два множества пар: 
\begin{equation*}
	L = \{t_i, obj_i\}, R = \{t_j, obj_j\}
\end{equation*}

Объекты полученные до вызова \mintinline{java}{call} обозначим $L$, а после \mintinline{java}{call} -- $R$

После этого нужно восстановить переходы между множествами $L$ и $R$, которые соответствуют вызову \mintinline{java}{call}.

\textbf{Прямым переходом} для элемента $l \in L$ множество $R' \subset R$ такое, что $\forall r \in R'$ объект $r$ является результатом воздействия операции \mintinline{java}{call} на элемент $l$.

По аналогии можно определить и \textbf{обратный переход}.
Правила, по которым строятся прямые и обратные отображения для конкретных вызовов описаны в \ref{interpret}.

Для большинства промежуточных операций множеств $L$ и $R$ достаточно для построения переходов. Единственное исключение -- промежуточная операция \mintinline{java}{distinct}. Решение для него предложим немного позже в TODO;

\subsubsection{Вычисление выражения}
Все отладчики внутри сред разработки предоставляют возможность вычислять выражения на java код при попадании на точку останова.

\subsubsection{Интерпретация результата}\label{interpret}

Как мы сказали в \ref{build-expression} результатом выполнения выражения является набор множеств $L$ и $R$ для каждой промежуточной операции. Рассмотрим алгоритмы построения переходов для каждого из промежуточных вызовов стандартной реализации Stream API.
\begin{itemize}
	\item map -- 
	\item filter --
	\item flatMap --
	\item sorted --
\end{itemize}

Выше перечислены методы для которых построение переходов различается. Для остальных вызовов можно использовать эти же алгоритмы, т.к. они в смысле переходов являются частным случаев описанных выше операций.
\begin{itemize}
	%linked
	\item limit --
	\item skip --
	\item peek --
	\item onClose -- 
\end{itemize}  


\subsubsection{Решение для операции distinct}
$distinct$ -- промежуточная операция c состоянием, поэтому прежде чем что-то вернуть ей может понадобиться прочитать весь входной поток. Результатом является поток объектов, для которого гарантируется, что все объекты попарно различны (в смысле equals\cite{java:equals}). Новых объектов при этом появиться, очевидно не может.

Условие что операция имеет состояние не позволяет использовать времена $t_i, t_j$ для разрешения порядка. Поэтому мы может только сравнивать объекты. 

\subsection{Визуализация}

